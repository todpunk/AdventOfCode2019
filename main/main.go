package main

import (
	"bufio"
	"fmt"
	"gopkg.in/alecthomas/kingpin.v2"
	"log"
	"math"
	"math/big"
	"math/rand"
	"os"
	"os/exec"
	"sort"
	"strconv"
	"strings"
	"time"
)

var (
	day   = kingpin.Arg("day", "Advent day to run").Int()
)

func main() {
	kingpin.Version("0.0.1")
	kingpin.Parse()
	rand.Seed(time.Now().UTC().UnixNano())
	fmt.Printf("Would run day: %d\n", *day)
	switch *day {
	case 1:
		day1()
	case 2:
		day2()
	case 3:
		day3()
	case 4:
		day4()
	case 5:
		day5()
	case 6:
		day6()
	case 7:
		day7()
	case 8:
		day8()
	case 9:
		day9()
	case 10:
		day10()
	case 11:
		day11()
	case 12:
		day12()
	case 13:
		day13()
	case 14:
		day14()
	case 15:
		day15()
	case 16:
		day16()
	case 17:
		day17()
	case 18:
		day18()
	case 19:
		day19()
	case 20:
		day20()
	case 21:
		day21()
	case 22:
		day22()
	case 23:
		day23()
	case 24:
		day24()
	default:
		fmt.Println("We don't have that day...")
	}
}

func day1() {
	file, err := os.Open("./day1-input.txt")
	if err != nil {
		log.Fatal(err)
	}
	defer file.Close()

	var modules []int64
	var sum int64 = 0
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		var module int64
		module, _ = strconv.ParseInt(scanner.Text(), 10, 32)
		sum += module / 3.0 - 2
		modules = append(modules, module)
	}

	fmt.Printf("Total fuel required: %d\n", sum)
	fmt.Println("But we need to fuel that fuel, so....")

	var newFuel int64
	sum = 0
	for i, _ := range modules {
		for newFuel = modules[i]; newFuel > 0; {
			newFuel = newFuel / 3 - 2
			if newFuel > 0 {
				sum += newFuel
			}
		}
	}
	fmt.Printf("New Total fuel required (calculated per module): %d\n", sum)
}

func getParamValueWithMode(codes map[int64]int64, mode int64, location int64, relativeBase int64) (param int64) {
	switch mode {
	case 0:
		return codes[codes[location]]
	case 1:
		return codes[location]
	case 2:
		return codes[relativeBase+codes[location]]
	default:
		fmt.Printf("Can not get with mode %d as it is unknown at location %d\n", mode, location)
		return -1
	}
}
func setParamWithMode(codes map[int64]int64, mode int64, location int64, value int64, relativeBase int64) (result int64) {
	switch mode {
	case 0:
		codes[codes[location]] = value
	case 1:
		// Yes, I know this should never occur.  But it wasn't called out as explicitly not able to occur.
		codes[location] = value
	case 2:
		codes[relativeBase+codes[location]] = value
	default:
		fmt.Printf("Can not set with mode %d as it is unknown at location %d\n", mode, location)
		return -1
	}
	return 0
}

type inputGatherer func() int64
type outputHandler func(int64)

func gatherInputFromUser() (result int64) {
	fmt.Print("Enter number: ")
	_, _ = fmt.Scanf("%d", &result)
	fmt.Println("Input was:", result)
	return result
}

func printOutputHandler(output int64) {
	fmt.Println("Output:", output)
}

func runIntComp(codes []int64, gatherer inputGatherer, outputFunc outputHandler) (pos0 int64 ) {
	var i int64
	var relativeBase int64
	var codesMap = map[int64]int64{}

	for i = 0; i < int64(len(codes)); i++ {
		codesMap[i] = codes[i]
	}

	for i = 0; i < int64(len(codes)-1);  {
		opcode := codesMap[i] % 100
		mode1 := (codesMap[i] / 100) % 10
		mode2 := (codesMap[i] / 1000) % 10
		mode3 := (codesMap[i] / 10000) % 10
		switch opcode {
		case 99:
			i = int64(len(codes))
		case 1:
			a := getParamValueWithMode(codesMap, mode1, i+1, relativeBase)
			b := getParamValueWithMode(codesMap, mode2, i+2, relativeBase)
			result := setParamWithMode(codesMap, mode3, i+3, a + b, relativeBase)
			if result == -1 {
				i = int64(len(codes))
			}
			i += 4
		case 2:
			a := getParamValueWithMode(codesMap, mode1, i+1, relativeBase)
			b := getParamValueWithMode(codesMap, mode2, i+2, relativeBase)
			result := setParamWithMode(codesMap, mode3, i+3, a * b, relativeBase)
			if result == -1 {
				i = int64(len(codes))
			}
			i += 4
		case 3:
			input := gatherer()
			result := setParamWithMode(codesMap, mode1, i+1, input, relativeBase)
			if result == -1 {
				i = int64(len(codes))
			}
			i += 2
		case 4:
			outputFunc(getParamValueWithMode(codesMap, mode1, i+1, relativeBase))
			i += 2
		case 5:
			first := getParamValueWithMode(codesMap, mode1, i+1, relativeBase)
			if first != 0 {
				i = getParamValueWithMode(codesMap, mode2, i+2, relativeBase)
			} else {
				i += 3
			}
		case 6:
			first := getParamValueWithMode(codesMap, mode1, i+1, relativeBase)
			if first == 0 {
				i = getParamValueWithMode(codesMap, mode2, i+2, relativeBase)
			} else {
				i += 3
			}
		case 7:
			first := getParamValueWithMode(codesMap, mode1, i+1, relativeBase)
			second := getParamValueWithMode(codesMap, mode2, i+2, relativeBase)
			var result int64
			if first < second {
				result = setParamWithMode(codesMap, mode3, i+3, 1, relativeBase)
			} else {
				result = setParamWithMode(codesMap, mode3, i+3, 0, relativeBase)
			}
			i += 4
			if result == -1 {
				i = int64(len(codes))
			}
		case 8:
			first := getParamValueWithMode(codesMap, mode1, i+1, relativeBase)
			second := getParamValueWithMode(codesMap, mode2, i+2, relativeBase)
			var result int64
			if first == second {
				result = setParamWithMode(codesMap, mode3, i+3, 1, relativeBase)
			} else {
				result = setParamWithMode(codesMap, mode3, i+3, 0, relativeBase)
			}
			i += 4
			if result == -1 {
				i = int64(len(codes))
			}
		case 9:
			//fmt.Println("Raw instruction and such:", i, codesMap[i], codesMap[i+1])
			first := getParamValueWithMode(codesMap, mode1, i+1, relativeBase)
			relativeBase += first
			i += 2
		default:
			i = int64(len(codes))
			fmt.Printf("This went poorly, opcode: %d at %d\n", opcode, i)
		}
	}
	return codesMap[0]
}

func day2() {
	rawCodes := []int64{1,0,0,3,1,1,2,3,1,3,4,3,1,5,0,3,2,9,1,19,1,19,5,23,1,23,6,27,2,9,27,31,1,5,31,35,1,35,10,39,1,39,10,43,2,43,9,47,1,6,47,51,2,51,6,55,1,5,55,59,2,59,10,63,1,9,63,67,1,9,67,71,2,71,6,75,1,5,75,79,1,5,79,83,1,9,83,87,2,87,10,91,2,10,91,95,1,95,9,99,2,99,9,103,2,10,103,107,2,9,107,111,1,111,5,115,1,115,2,119,1,119,6,0,99,2,0,14,0}
	var codes = make([]int64, len(rawCodes))
	copy(codes, rawCodes)
	fmt.Println(rawCodes)
	fmt.Println(codes)
	codes[1] = 12
	codes[2] = 2
	fmt.Printf("Position 0: %d\n", runIntComp(codes, gatherInputFromUser, printOutputHandler))

	var pos0, noun, verb int64
	for noun = 1; noun < 100; noun++ {
		for verb = 1; verb < 100; verb++ {
			copy(codes, rawCodes)
			codes[1] = noun
			codes[2] = verb
			pos0 = runIntComp(codes, gatherInputFromUser, printOutputHandler)
			if pos0 == 19690720 {
				fmt.Printf("Noun: %d Verb: %d Result: %d\n", noun, verb, 100 * noun + verb)
				noun = 99
				verb = 99
			}
		}
	}
}

type gridPoint struct{
	x int64
	y int64
}

func Abs(x int64) int64 {
	if x < 0 {
		return -x
	}
	return x
}
func AbsInt(x int) int {
	if x < 0 {
		return -x
	}
	return x
}

func calculateWire(wirePoints map[gridPoint]int64, wire []string){
	var dirs = map[string]gridPoint{
		"R": {1,0},
		"L": {-1,0},
		"U": {0,1},
		"D": {0,-1},
	}

	var current = gridPoint{0,0}
	var totalSteps int64 = 0
	for _, segment := range wire {
		dir := string(segment[0])
		var distance int64
		distance, _ = strconv.ParseInt(segment[1:], 10, 64)
		var i int64
		for i = 0; i < distance; i++ {
			totalSteps += 1
			current.x += dirs[dir].x
			current.y += dirs[dir].y
			wirePoints[current] = totalSteps
		}
	}
}

func calculateOverlap(a, b map[gridPoint]int64) (c map[gridPoint]int64) {
	c = make(map[gridPoint]int64)

	for item, valB := range b {
		if _, ok := a[item]; ok {
			c[item] = a[item] + valB
		}
	}
	return
}

func day3() {
	var wire1 = []string{"R1009","U263","L517","U449","L805","D78","L798","D883","L777","D562","R652","D348","R999","D767","L959","U493","R59","D994","L225","D226","R634","D200","R953","U343","L388","U158","R943","U544","L809","D785","R618","U499","L476","U600","L452","D693","L696","U764","L927","D346","L863","D458","L789","U268","R586","U884","L658","D371","L910","U178","R524","U169","R973","D326","R483","U233","R26","U807","L246","D711","L641","D75","R756","U365","R203","D377","R624","U430","L422","U367","R547","U294","L916","D757","R509","D332","R106","D401","L181","U5","L443","U197","R406","D829","R878","U35","L958","U31","L28","D362","R188","D582","R358","U750","R939","D491","R929","D513","L541","U418","R861","D639","L917","U582","R211","U725","R711","D718","L673","U921","L157","U83","L199","U501","L66","D993","L599","D947","L26","U237","L981","U833","L121","U25","R641","D372","L757","D645","R287","U390","R274","U964","R288","D209","R109","D364","R983","U715","L315","U758","R36","D500","R626","U893","L840","U716","L606","U831","L969","D643","L300","D838","R31","D751","L632","D702","R468","D7","L169","U149","R893","D33","R816","D558","R152","U489","L237","U415","R434","D472","L198","D874","L351","U148","R761","U809","R21","D25","R586","D338","L568","U20","L157","U221","L26","U424","R261","D227","L551","D754","L90","U110","L791","U433","R840","U323","R240","U124","L723","D418","R938","D173","L160","U293","R773","U204","R192","U958","L472","D703","R556","D168","L263","U574","L845","D932","R165","D348","R811","D834","R960","U877","R935","D141","R696","U748","L316","U236","L796","D566","R524","U449","R378","U480","L79","U227","R867","D185","R474","D757","R366","U153","R882","U252","R861","U900","R28","U381","L845","U642","L849","U352","R134","D294","R788","D406","L693","D697","L433","D872","R78","D364","R240","U995","R48","D681","R727","D825","L583","U44","R743","D929","L616","D262","R997","D15","R575","U341","R595","U889","R254","U76","R962","D944","R724","D261","R608","U753","L389","D324","L569","U308","L488","D358","L695","D863","L712","D978","R149","D177","R92"}
	var wire2 = []string{"L1003","D960","L10","D57","R294","U538","R867","D426","L524","D441","R775","U308","R577","D785","R495","U847","R643","D895","R448","U685","L253","U312","L312","U753","L89","U276","R799","D923","L33","U595","R400","U111","L664","D542","R171","U709","L809","D713","L483","U918","L14","U854","L150","D69","L158","D500","L91","D800","R431","D851","L798","U515","L107","U413","L94","U390","L17","U221","L999","D546","L191","U472","L568","U114","L913","D743","L713","D215","L569","D674","L869","U549","L789","U259","L330","D76","R243","D592","L646","U880","L363","U542","L464","D955","L107","U473","R818","D786","R852","U968","R526","D78","L275","U891","R480","U991","L981","D391","R83","U691","R689","D230","L217","D458","R10","U736","L317","D145","R902","D428","R344","U334","R131","D739","R438","D376","L652","U304","L332","D452","R241","D783","R82","D317","R796","U323","R287","D487","L302","D110","R233","U631","R584","U973","L878","D834","L930","U472","R120","U78","R806","D21","L521","U988","R251","D817","R44","D789","R204","D669","R616","D96","R624","D891","L532","U154","R438","U469","R785","D431","R945","U649","R670","D11","R840","D521","L235","D69","L551","D266","L454","U807","L885","U590","L647","U763","R449","U194","R68","U809","L884","U962","L476","D648","L139","U96","L300","U351","L456","D202","R168","D698","R161","U834","L273","U47","L8","D157","L893","D200","L454","U723","R886","U92","R474","U262","L190","U110","L407","D723","R786","D786","L572","D915","L904","U744","L820","D663","R205","U878","R186","U247","L616","D386","R582","U688","L349","D399","R702","U132","L276","U866","R851","D633","R468","D263","R678","D96","L50","U946","R349","D482","R487","U525","R464","U977","L499","D187","R546","U708","L627","D470","R673","D886","L375","U616","L503","U38","L775","D8","L982","D556","R159","U680","L124","U777","L640","D607","R248","D671","L65","D290","R445","U778","L650","U679","L846","D1","L769","U659","R734","D962","R588","U178","R888","D753","R223","U318","L695","D586","R430","D61","R105","U801","R953","U721","L856","U769","R937","D335","R895"}

	var wire1Points = map[gridPoint]int64{}
	var wire2Points = map[gridPoint]int64{}

	calculateWire(wire1Points, wire1)
	calculateWire(wire2Points, wire2)
	var overlaps = calculateOverlap(wire1Points, wire2Points)

	var distance int64 = math.MaxInt64
	var totalSteps int64 = math.MaxInt64
	for overlap, steps := range overlaps {
		var pointDistance = Abs(overlap.x) + Abs(overlap.y)
		if pointDistance < distance {
			distance = pointDistance
		}
		if steps < totalSteps {
			totalSteps = steps
		}
	}
	fmt.Println(distance)
	fmt.Println(totalSteps)
}

func isPotentialPassword(password int64) (correct bool){
	var strPass string = strconv.FormatInt(password, 10)
	var doubleMap = map[int32]int64{}
	var doublesFound int64 = 0

	var last int64 = 0
	for _, c := range strPass {
		var current, _ = strconv.ParseInt(strconv.FormatInt(int64(c), 10), 10, 32)
		if last > current {
			return false
		}
		doubleMap[c] += 1
		// This if statement is only useful for part 2
		if doubleMap[c] == 3 {
			doublesFound--
		}
		if doubleMap[c] == 2 {
			doublesFound++
		}
		last = current
	}
	// If we have made it this far, the only criteria left is if there are doubles somewhere in there
	return doublesFound > 0
}

func day4() {
	var possibility, potentials int64
	potentials = 0

	for possibility = 108457; possibility <= 562041; possibility++ {
		if isPotentialPassword(possibility) {
			potentials++
		}
	}
	fmt.Println(potentials)
}

func day5() {
	rawcodes := []int64{3,225,1,225,6,6,1100,1,238,225,104,0,1101,48,82,225,102,59,84,224,1001,224,-944,224,4,224,102,8,223,223,101,6,224,224,1,223,224,223,1101,92,58,224,101,-150,224,224,4,224,102,8,223,223,1001,224,3,224,1,224,223,223,1102,10,89,224,101,-890,224,224,4,224,1002,223,8,223,1001,224,5,224,1,224,223,223,1101,29,16,225,101,23,110,224,1001,224,-95,224,4,224,102,8,223,223,1001,224,3,224,1,223,224,223,1102,75,72,225,1102,51,8,225,1102,26,16,225,1102,8,49,225,1001,122,64,224,1001,224,-113,224,4,224,102,8,223,223,1001,224,3,224,1,224,223,223,1102,55,72,225,1002,174,28,224,101,-896,224,224,4,224,1002,223,8,223,101,4,224,224,1,224,223,223,1102,57,32,225,2,113,117,224,101,-1326,224,224,4,224,102,8,223,223,101,5,224,224,1,223,224,223,1,148,13,224,101,-120,224,224,4,224,1002,223,8,223,101,7,224,224,1,223,224,223,4,223,99,0,0,0,677,0,0,0,0,0,0,0,0,0,0,0,1105,0,99999,1105,227,247,1105,1,99999,1005,227,99999,1005,0,256,1105,1,99999,1106,227,99999,1106,0,265,1105,1,99999,1006,0,99999,1006,227,274,1105,1,99999,1105,1,280,1105,1,99999,1,225,225,225,1101,294,0,0,105,1,0,1105,1,99999,1106,0,300,1105,1,99999,1,225,225,225,1101,314,0,0,106,0,0,1105,1,99999,8,677,226,224,102,2,223,223,1006,224,329,101,1,223,223,107,677,677,224,1002,223,2,223,1006,224,344,101,1,223,223,8,226,677,224,102,2,223,223,1006,224,359,101,1,223,223,107,226,226,224,102,2,223,223,1005,224,374,1001,223,1,223,1108,677,226,224,1002,223,2,223,1006,224,389,101,1,223,223,107,677,226,224,102,2,223,223,1006,224,404,1001,223,1,223,1107,226,677,224,1002,223,2,223,1006,224,419,1001,223,1,223,108,677,677,224,102,2,223,223,1005,224,434,1001,223,1,223,1008,677,226,224,1002,223,2,223,1006,224,449,1001,223,1,223,7,226,677,224,1002,223,2,223,1006,224,464,1001,223,1,223,1007,677,677,224,102,2,223,223,1005,224,479,1001,223,1,223,1007,226,226,224,1002,223,2,223,1005,224,494,1001,223,1,223,108,226,226,224,1002,223,2,223,1005,224,509,1001,223,1,223,1007,226,677,224,1002,223,2,223,1006,224,524,101,1,223,223,1107,677,677,224,102,2,223,223,1005,224,539,101,1,223,223,1107,677,226,224,102,2,223,223,1005,224,554,1001,223,1,223,108,677,226,224,1002,223,2,223,1006,224,569,1001,223,1,223,1108,226,677,224,1002,223,2,223,1006,224,584,101,1,223,223,8,677,677,224,1002,223,2,223,1006,224,599,1001,223,1,223,1008,226,226,224,102,2,223,223,1006,224,614,101,1,223,223,7,677,677,224,1002,223,2,223,1006,224,629,101,1,223,223,1008,677,677,224,102,2,223,223,1005,224,644,101,1,223,223,7,677,226,224,1002,223,2,223,1005,224,659,101,1,223,223,1108,226,226,224,102,2,223,223,1006,224,674,1001,223,1,223,4,223,99,226}
	var codes = make([]int64, len(rawcodes))
	copy(codes, rawcodes)
	runIntComp(codes, gatherInputFromUser, printOutputHandler)
}

type orbit struct {
	orbiting  string
	centering []string
}

func (n *orbit) SetOrbiting(value string) {
	n.orbiting = value
}

func (n *orbit) AppendCentering(value string) {
	n.centering = append(n.centering, value)
}

func getOrbitMapDistances(orbits map[string]orbit, center string, depth int64) (direct int64, indirect int64) {
	direct = int64(len(orbits[center].centering))
	indirect = depth * direct
	for _, item := range orbits[center].centering {
		newDirect, newIndirect := getOrbitMapDistances(orbits, item, depth+1)
		direct += newDirect
		indirect += newIndirect
	}

	return direct, indirect
}

func day6() {
	file, err := os.Open("./day6-input.txt")
	if err != nil {
		log.Fatal(err)
	}
	defer file.Close()

	var orbits = map[string]orbit{}
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		var rawOrbit string
		rawOrbit = scanner.Text()
		orbitRelationship := strings.Split(rawOrbit,")")
		if _, ok := orbits[orbitRelationship[0]]; ! ok {
			orbits[orbitRelationship[0]] = orbit{"", []string{}}
		}
		if _, ok := orbits[orbitRelationship[1]]; ! ok {
			orbits[orbitRelationship[1]] = orbit{orbitRelationship[0], []string{}}
		} else {
			thisOrbit := orbits[orbitRelationship[1]]
			thisOrbit.SetOrbiting(orbitRelationship[0])
			orbits[orbitRelationship[1]] = thisOrbit
		}
		thisOrbit := orbits[orbitRelationship[0]]
		thisOrbit.AppendCentering(orbitRelationship[1])
		orbits[orbitRelationship[0]] = thisOrbit
	}

	direct, indirect := getOrbitMapDistances(orbits, "COM", 0)
	fmt.Println("Total orbits:", direct + indirect)

	var youBackwards = map[string]int64{}
	var i int64
	var current string
	var found bool

	found = true
	current = "YOU"
	for i = -1; found; i++ {
		fmt.Println("Current:", current)
		youBackwards[current] = i
		current = orbits[current].orbiting
		if current == "COM" {
			found = false
		}
	}
	fmt.Println("Transfers from COM", youBackwards["COM"])

	current = "SAN"
	found = true
	var total int64
	for i = 0; found; i++ {
		current = orbits[current].orbiting
		if _, ok := youBackwards[current]; ok {
			total = youBackwards[current] + i
			found = false
		}
	}
	fmt.Println("Total orbit transfers", total)
}

func generateCombinationsOfInts(initial []int64) (allCombos [][]int64) {
	var rc func([]int64, int64)
	rc = func(a []int64, k int64) {
		if k == int64(len(a)) {
			allCombos = append(allCombos, append([]int64{}, a...))
		} else {
			for i := k; i < int64(len(initial)); i++ {
				a[k], a[i] = a[i], a[k]
				rc(a, k+1)
				a[k], a[i] = a[i], a[k]
			}
		}
	}
	rc(initial, 0)

	return allCombos
}

func generatePrimedIOHandlers(inputs []int64) (forInput inputGatherer, forOutput outputHandler, getLastOutput func() int64) {
	var current int64
	var lastOutput int64
	forInput = func() (nextInput int64){
		nextInput = inputs[current]
		current++
		return nextInput
	}
	forOutput = func(output int64) {
		lastOutput = output
		if current < int64(len(inputs)) {
			inputs = append(inputs[:current+1], append([]int64{output}, inputs[current+1:]...)...)
		}
	}
	getLastOutput = func() int64 {
		return lastOutput
	}
	return forInput, forOutput, getLastOutput
}

func generateContinuousIOHandlers(phase int64, inputChan chan int64, outputChan chan int64, ampNum int64) (forInput inputGatherer, forOutput outputHandler, getLastOutput func() int64) {
	var phaseGiven = false
	var lastOutput int64
	forInput = func() (nextInput int64){
		if ! phaseGiven {
			phaseGiven = true
			return phase
		}
		nextInput = <- inputChan
		return nextInput
	}
	forOutput = func(output int64) {
		lastOutput = output
		outputChan <- output
	}
	getLastOutput = func() int64 {
		return lastOutput
	}
	return forInput, forOutput, getLastOutput
}

func runAmplifier(amplifier int, codes []int64, inputFunc inputGatherer, outputFunc outputHandler, finished chan bool) {
	runIntComp(codes, inputFunc, outputFunc)
	finished <- true
}

func day7() {
	rawCodes := []int64{3,8,1001,8,10,8,105,1,0,0,21,46,55,68,89,110,191,272,353,434,99999,3,9,1002,9,3,9,1001,9,3,9,102,4,9,9,101,4,9,9,1002,9,5,9,4,9,99,3,9,102,3,9,9,4,9,99,3,9,1001,9,5,9,102,4,9,9,4,9,99,3,9,1001,9,5,9,1002,9,2,9,1001,9,5,9,1002,9,3,9,4,9,99,3,9,101,3,9,9,102,3,9,9,101,3,9,9,1002,9,4,9,4,9,99,3,9,1001,9,1,9,4,9,3,9,1001,9,1,9,4,9,3,9,102,2,9,9,4,9,3,9,1001,9,2,9,4,9,3,9,1001,9,2,9,4,9,3,9,1002,9,2,9,4,9,3,9,101,2,9,9,4,9,3,9,1002,9,2,9,4,9,3,9,1001,9,1,9,4,9,3,9,1001,9,2,9,4,9,99,3,9,102,2,9,9,4,9,3,9,101,2,9,9,4,9,3,9,101,2,9,9,4,9,3,9,1001,9,1,9,4,9,3,9,102,2,9,9,4,9,3,9,101,2,9,9,4,9,3,9,1002,9,2,9,4,9,3,9,101,1,9,9,4,9,3,9,101,2,9,9,4,9,3,9,101,2,9,9,4,9,99,3,9,101,2,9,9,4,9,3,9,102,2,9,9,4,9,3,9,101,1,9,9,4,9,3,9,101,2,9,9,4,9,3,9,1002,9,2,9,4,9,3,9,101,2,9,9,4,9,3,9,1002,9,2,9,4,9,3,9,102,2,9,9,4,9,3,9,1001,9,1,9,4,9,3,9,101,2,9,9,4,9,99,3,9,102,2,9,9,4,9,3,9,102,2,9,9,4,9,3,9,101,1,9,9,4,9,3,9,1002,9,2,9,4,9,3,9,102,2,9,9,4,9,3,9,1002,9,2,9,4,9,3,9,1001,9,2,9,4,9,3,9,101,2,9,9,4,9,3,9,101,2,9,9,4,9,3,9,1001,9,1,9,4,9,99,3,9,1002,9,2,9,4,9,3,9,101,2,9,9,4,9,3,9,1001,9,1,9,4,9,3,9,101,1,9,9,4,9,3,9,101,2,9,9,4,9,3,9,102,2,9,9,4,9,3,9,102,2,9,9,4,9,3,9,1002,9,2,9,4,9,3,9,1001,9,1,9,4,9,3,9,102,2,9,9,4,9,99}
	var codes = make([]int64, len(rawCodes))
	var allInputs [][]int64
	var bestInput []int64
	var largestResult int64

	allInputs = generateCombinationsOfInts([]int64{0,1,2,3,4})
	bestInput = []int64{0,1,2,3,4}
	for _, inputSet := range allInputs {
		var potentialBestInputs = make([]int64, len(inputSet))
		copy(potentialBestInputs, inputSet)
		inputSet = append(inputSet[:1], append([]int64{0}, inputSet[1:]...)...)
		gatherer, outputFunc, getLastOutput := generatePrimedIOHandlers(inputSet)
		copy(codes, rawCodes)

		for i := 0; i < 5; i++ {
			runIntComp(codes, gatherer, outputFunc)
		}
		if getLastOutput() > largestResult {
			largestResult = getLastOutput()
			bestInput = potentialBestInputs
		}
	}
	fmt.Println("Best input:", bestInput, "Value:", largestResult)

	// testInput := []int64{3,26,1001,26,-4,26,3,27,1002,27,2,27,1,27,26,27,4,27,1001,28,-1,28,1005,28,6,99,0,0,5}
	allInputs = generateCombinationsOfInts([]int64{5,6,7,8,9})
	bestInput = []int64{5,6,7,8,9}
	largestResult = 0
	for _, inputSet := range allInputs {
		var potentialBestInput = make([]int64, len(inputSet))
		copy(potentialBestInput, inputSet)

		var inputGatherers = make([]inputGatherer, 5)
		var outputFunctions = make([]outputHandler, 5)
		var ampChannels = make([]chan int64, 5)
		var finished = make([]chan bool, 5)
		var lastOutputOfE = func() int64 {return -1}

		for i := 0; i < 5; i++ {
			ampChannels[i] = make(chan int64, 10)
		}

		for i := 0; i < 5; i++ {
			var inputChannel = ampChannels[i]
			var outputChannel = ampChannels[(i+1)%5]
			gatherer, outputFunc, getLastOutput := generateContinuousIOHandlers(inputSet[i], inputChannel, outputChannel, int64(i))
			inputGatherers[i] = gatherer
			outputFunctions[i] = outputFunc
			// We only need the output of E at the end
			if i == 4 {
				lastOutputOfE = getLastOutput
			}
		}
		// A separate loop since we have to have the handlers generated
		for i := 0; i < 5; i++ {
			var finisher = make(chan bool)
			finished[i] = finisher
			var copiedcodes = make([]int64, len(rawCodes))
			copy(copiedcodes, rawCodes)
			go runAmplifier(i, copiedcodes, inputGatherers[i], outputFunctions[i], finisher)
		}
		ampChannels[0] <- 0
		for i := 0; i < 5; i++ {
			<- finished[i]
		}

		if lastOutputOfE() > largestResult {
			largestResult = lastOutputOfE()
			bestInput = potentialBestInput
		}
	}
	fmt.Println("Best feedback input:", bestInput, "Value:", largestResult)
}

type layerStats struct {
	layer int
	zeroes int
	ones int
	twos int
	data []int
}

func (n *layerStats) SetZeroes(value int) {
	n.zeroes = value
}
func (n *layerStats) SetLayer(value int) {
	n.zeroes = value
}
func (n *layerStats) SetOnes(value int) {
	n.ones = value
}
func (n *layerStats) SetTwos(value int) {
	n.twos = value
}


func calcPixel(pixels []int) int {
	for _, pixel := range pixels {
		switch pixel {
		case 0:
			return 0
		case 1:
			return 1
		}
	}
	return 2
}

func day8() {
	rawDigits := []int{1,1,2,2,2,2,2,0,2,2,2,2,2,2,2,2,0,2,0,2,2,2,2,2,2,0,2,0,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,0,0,2,2,2,2,2,2,2,1,2,0,2,2,2,2,2,2,2,1,2,2,1,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,0,2,2,0,2,2,2,2,2,1,2,2,1,2,2,2,2,2,2,0,2,2,2,0,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,1,2,0,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,1,2,1,2,2,0,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,0,2,2,1,2,2,2,2,2,2,1,2,2,2,0,2,1,0,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,0,2,1,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,0,1,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,1,2,0,2,2,0,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,0,2,2,1,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,0,2,2,2,1,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,1,2,1,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,1,0,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,1,2,0,2,2,0,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,1,2,0,0,2,2,2,2,2,0,2,2,1,2,2,2,2,2,2,1,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,0,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,0,2,0,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,0,2,1,2,2,2,2,2,2,2,2,2,2,2,0,1,2,2,2,2,0,1,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,2,1,2,1,2,2,2,2,2,2,1,2,1,2,2,2,2,2,2,1,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,1,1,2,0,1,2,2,2,2,0,0,2,2,1,2,2,2,2,2,2,1,0,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,1,0,2,2,2,2,2,2,2,1,2,1,2,2,2,2,2,0,2,1,2,2,0,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,1,2,2,2,2,2,0,2,2,2,0,2,0,2,2,2,2,2,2,2,2,0,1,2,1,1,2,2,2,2,1,0,2,2,2,2,2,2,2,2,2,1,1,2,2,0,2,0,0,2,2,2,2,2,2,2,2,2,2,2,2,1,0,2,2,2,2,2,0,2,2,2,2,2,2,2,2,1,0,1,2,2,2,2,2,2,1,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,0,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,1,2,1,0,2,2,2,2,0,0,2,2,1,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,1,2,2,2,2,2,2,2,2,1,2,0,2,2,2,2,2,1,2,1,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,0,2,2,2,2,2,0,2,2,2,0,2,1,2,2,2,2,2,2,2,2,1,1,2,0,0,2,2,2,2,0,2,2,2,1,2,2,2,2,2,2,0,2,2,2,1,2,0,0,2,0,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,1,2,0,2,2,2,2,2,2,0,1,1,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,0,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,1,2,2,0,2,0,2,2,2,2,2,2,2,2,2,2,0,2,2,2,0,1,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,0,2,1,2,2,2,2,2,2,2,2,1,0,2,0,1,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,1,2,2,0,2,0,0,2,1,2,2,2,2,2,2,2,2,2,2,0,1,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,0,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,1,0,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,0,2,1,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,0,2,2,2,2,0,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,0,1,2,0,2,2,1,0,2,2,1,2,2,2,2,2,2,1,0,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,1,2,2,2,2,2,1,2,1,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,0,1,2,2,2,2,2,2,2,1,2,1,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,0,2,2,2,2,2,1,2,2,2,2,1,2,2,2,2,1,2,1,2,2,2,2,2,2,2,2,2,1,2,1,1,2,0,2,0,2,1,2,2,2,2,2,2,2,2,2,0,1,2,2,1,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,1,1,0,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,0,2,1,2,2,2,2,2,2,2,0,2,2,1,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,0,1,0,2,2,0,2,2,2,2,2,2,1,1,2,2,1,2,2,0,2,0,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,1,2,0,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,1,2,1,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,0,2,2,2,2,2,2,2,2,1,2,0,2,2,2,2,2,1,2,1,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,1,0,2,2,2,1,2,2,2,2,2,2,2,2,2,2,1,2,2,0,2,2,0,2,1,1,2,2,2,1,2,2,2,2,2,2,2,0,2,2,2,2,0,0,2,2,2,2,2,2,2,2,2,2,2,2,0,1,2,2,2,0,2,0,2,1,2,2,2,2,2,2,0,0,1,2,2,2,2,2,2,1,2,0,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,0,2,1,2,2,2,2,2,2,2,2,2,2,1,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,0,2,2,2,2,2,2,2,2,2,2,1,0,2,1,1,2,1,2,0,2,2,2,2,2,2,2,2,2,2,2,1,0,2,2,2,2,0,0,2,1,2,1,2,2,2,2,2,2,2,2,2,0,2,2,2,0,2,1,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,1,2,2,2,2,2,2,2,0,2,0,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,1,1,2,2,2,2,2,1,2,2,2,2,1,1,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,0,2,2,2,2,2,2,2,2,2,0,1,2,2,0,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,1,2,2,2,1,2,0,2,0,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,0,2,2,1,2,1,2,2,2,2,2,2,2,2,2,2,1,2,2,2,0,0,2,2,2,2,2,2,2,2,2,2,2,0,2,0,2,2,2,0,2,2,2,2,2,2,2,2,1,1,2,1,0,2,1,2,1,1,1,2,2,0,2,2,2,2,2,2,2,0,2,2,2,2,2,1,2,2,2,0,2,2,2,2,2,2,2,2,2,0,2,2,2,1,2,0,2,1,2,2,2,2,2,2,0,1,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,0,1,2,2,2,1,1,2,1,2,1,2,1,2,2,2,2,2,2,2,2,2,2,2,1,2,2,0,2,2,1,1,2,2,1,2,2,2,2,2,2,0,0,2,2,2,2,0,2,2,2,2,1,2,2,2,2,2,2,2,2,2,0,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,1,2,2,2,2,2,2,2,1,2,2,2,1,2,2,1,2,0,2,2,2,2,2,2,2,2,2,2,1,0,2,1,1,2,2,2,1,1,1,2,2,0,2,2,2,2,2,2,1,1,2,2,2,2,1,1,2,1,2,1,2,2,2,2,2,2,2,2,1,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,0,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,0,2,0,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,1,2,2,2,2,2,1,1,2,2,2,1,1,2,2,2,0,2,1,2,2,2,2,2,2,2,2,0,0,2,0,0,2,1,2,2,1,1,2,2,1,2,2,2,2,2,2,1,2,2,2,2,2,2,1,2,1,2,1,2,2,2,2,2,2,2,2,1,1,2,2,2,0,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,1,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,0,0,2,2,2,2,2,0,2,2,2,2,2,2,2,1,2,1,2,1,2,2,2,2,2,2,2,2,0,1,2,0,2,2,2,2,2,2,1,2,2,1,2,2,2,2,2,2,0,2,2,2,0,2,1,2,2,0,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,0,2,2,2,2,2,2,2,2,2,2,0,2,0,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,0,0,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,1,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,0,2,2,2,0,0,2,2,2,2,2,1,0,2,2,2,0,1,2,1,2,0,2,2,2,2,2,2,2,2,2,2,2,0,2,0,1,2,0,2,0,1,1,2,2,0,2,2,2,2,2,2,2,2,2,2,1,2,0,2,2,1,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,0,2,1,2,2,2,2,2,2,2,1,0,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,1,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,0,2,0,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,1,1,1,2,2,2,1,0,2,1,2,0,2,1,2,2,2,2,2,2,2,2,2,0,2,1,0,2,2,2,1,0,1,2,2,0,2,2,2,2,2,2,0,1,2,2,1,2,0,0,2,0,2,1,2,2,2,2,2,2,2,2,0,1,2,2,2,0,2,2,2,2,2,2,2,2,2,2,0,0,0,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,0,2,2,2,2,2,2,2,2,1,2,0,2,2,2,2,2,1,2,1,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,1,2,2,2,2,2,1,2,1,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,0,0,2,1,0,2,2,2,0,2,2,2,2,1,2,2,2,2,2,2,1,1,2,2,0,2,0,0,2,0,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,0,2,0,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,1,2,2,2,2,2,2,2,1,2,0,2,2,2,2,2,2,2,0,2,2,0,2,1,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,0,2,2,2,2,2,1,2,2,2,2,1,2,2,2,2,0,2,0,2,2,2,2,2,2,2,2,1,2,2,1,0,2,2,2,0,1,2,2,2,1,2,2,2,2,2,2,2,1,2,2,1,2,1,1,2,0,2,1,2,2,2,2,2,2,2,2,0,1,2,2,0,0,2,0,2,1,2,2,2,2,2,2,2,1,0,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,0,0,2,2,2,2,2,2,2,0,2,1,2,2,2,2,2,0,2,2,2,2,1,2,2,2,2,1,2,2,2,2,2,2,2,0,2,2,2,1,1,2,2,2,2,0,2,2,2,2,2,1,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,1,1,1,2,2,1,2,2,2,2,2,2,2,1,2,2,2,2,1,1,2,0,2,0,2,2,2,2,2,2,2,2,0,1,2,2,0,0,2,0,2,0,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,1,2,0,2,2,1,2,0,2,2,0,2,2,2,2,2,2,2,1,0,2,2,0,2,2,2,2,2,1,0,0,2,2,2,2,1,2,2,2,0,2,2,2,2,2,2,2,1,2,2,1,0,2,1,0,2,1,2,2,0,0,2,2,0,2,2,2,2,2,2,2,2,2,2,1,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,0,0,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,1,2,2,2,2,2,2,2,1,2,1,2,2,2,2,2,2,2,1,2,2,1,2,2,2,2,1,2,2,2,2,2,2,2,1,2,2,2,0,1,2,2,2,2,1,2,2,2,2,2,2,2,2,1,2,2,2,0,2,2,2,2,2,1,2,2,2,2,2,1,2,2,2,2,0,1,2,2,2,1,2,2,2,2,2,2,1,2,2,2,0,2,2,0,2,0,2,1,2,2,2,2,2,2,2,2,1,1,2,2,1,0,2,0,2,2,2,2,1,2,2,2,0,1,0,2,2,2,2,2,2,0,2,0,2,2,2,0,2,2,2,2,2,1,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,0,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,1,2,0,2,2,2,0,1,2,0,2,0,2,0,2,2,2,2,2,2,2,2,1,2,2,2,2,2,1,0,1,0,0,2,2,1,2,2,2,2,2,2,1,2,2,2,0,2,2,0,2,0,2,1,2,2,2,2,2,2,2,2,0,0,2,2,1,1,2,1,2,2,2,2,0,2,2,2,0,1,1,2,2,2,2,2,2,2,2,0,2,2,1,1,2,2,2,2,2,1,2,2,2,2,2,2,0,2,2,2,2,2,2,2,1,2,0,2,2,2,2,2,1,2,0,2,2,2,2,1,2,2,1,2,2,2,2,2,2,2,1,0,2,2,1,0,2,2,2,2,1,0,2,2,2,2,1,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,0,2,1,0,2,2,0,2,1,0,2,2,0,2,2,2,2,2,2,1,0,2,2,0,2,1,1,2,1,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,0,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,1,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,2,2,1,0,2,2,2,2,0,0,2,2,2,2,1,2,2,0,2,1,2,2,2,2,2,2,2,0,2,2,0,1,2,2,0,2,2,1,0,1,0,2,2,0,2,2,2,2,2,2,0,0,2,2,1,2,2,2,2,0,2,1,2,2,2,2,2,2,2,2,0,0,2,2,0,1,2,2,2,0,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,1,2,0,2,2,0,0,2,2,2,2,2,1,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,0,2,1,2,2,2,2,2,2,2,2,2,2,0,1,2,2,0,2,2,2,2,2,1,0,1,2,2,2,2,2,2,0,2,0,2,0,2,2,2,2,2,2,2,2,0,2,2,0,0,2,2,1,2,0,1,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,0,1,2,2,2,1,2,2,2,2,2,2,2,2,0,2,2,2,1,0,2,1,2,1,2,2,2,2,2,2,0,0,1,2,2,2,2,2,2,0,2,1,2,2,0,0,2,2,2,2,2,0,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,1,2,2,2,2,2,2,2,2,1,2,2,2,1,2,2,2,2,0,2,0,2,2,2,0,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,1,2,0,0,0,2,0,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,0,2,2,2,1,2,2,2,2,2,2,2,2,0,1,2,2,1,1,2,2,2,0,2,2,2,2,2,2,1,0,2,2,1,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,1,2,2,2,2,2,2,2,1,2,0,2,2,2,2,2,1,2,1,2,2,2,2,1,2,2,1,2,2,2,2,2,2,2,2,2,2,2,0,2,0,2,2,2,2,2,2,2,2,2,2,0,2,2,2,0,2,2,2,2,0,2,2,1,2,2,0,0,2,1,0,2,2,1,2,1,1,2,2,0,2,2,2,2,2,2,2,2,2,2,0,2,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,0,2,1,2,2,1,2,2,2,0,2,0,2,1,2,2,2,2,1,2,2,2,0,1,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,1,2,1,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,0,0,2,2,1,0,2,2,2,2,2,0,1,2,2,2,0,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,1,0,2,1,0,1,1,1,2,2,1,2,2,2,2,2,2,1,0,2,2,1,2,0,0,2,0,2,0,2,2,2,2,2,2,2,2,0,0,2,2,0,1,2,0,2,2,2,2,0,2,2,2,0,0,0,2,1,2,0,2,2,0,2,2,2,1,0,2,2,2,2,2,2,1,2,2,1,2,2,2,1,2,2,2,2,2,2,2,1,2,1,2,2,2,2,2,1,2,1,2,2,2,2,1,2,2,1,2,1,2,2,2,2,2,0,2,2,2,1,0,0,2,2,2,1,1,1,2,2,2,2,2,2,0,2,1,2,1,2,2,2,2,2,0,2,2,1,0,2,0,1,2,0,2,1,0,0,2,2,2,2,2,2,2,2,2,1,1,0,0,0,2,0,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,1,2,2,2,2,0,2,2,2,2,0,0,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,1,2,2,2,2,2,1,1,2,2,2,2,2,2,2,1,2,1,2,2,2,2,2,2,2,1,2,2,2,2,1,2,2,1,2,0,1,2,2,2,2,0,2,2,2,0,2,1,2,2,2,1,1,2,2,2,2,2,2,2,2,2,0,2,1,2,2,2,2,2,1,2,2,0,0,2,1,2,2,2,1,1,0,2,2,2,2,2,2,2,2,2,2,2,1,2,1,1,2,0,0,2,0,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,0,2,2,2,0,2,2,1,2,2,2,2,2,1,2,0,2,0,2,2,0,2,2,2,0,1,2,2,2,2,2,2,0,2,2,1,2,2,1,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,1,2,0,2,2,0,2,2,2,2,0,2,0,2,2,2,2,2,1,1,2,2,1,0,0,2,2,2,1,2,1,2,2,2,2,2,2,1,2,1,2,2,2,2,2,2,2,2,2,0,2,1,2,1,2,2,0,2,2,2,1,2,2,0,2,2,2,2,2,2,0,0,1,1,0,2,0,1,2,0,2,0,2,2,2,2,2,2,2,2,2,0,2,2,1,0,2,1,2,2,2,2,2,2,2,2,0,0,0,2,2,2,1,2,2,0,2,0,2,2,1,2,2,2,2,2,2,1,2,2,1,2,2,2,0,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,0,2,1,2,2,2,2,2,2,2,0,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,0,1,2,1,2,1,2,2,2,2,1,2,2,0,2,2,2,2,2,1,2,2,2,1,0,1,1,2,2,2,2,2,2,2,2,2,0,0,1,0,1,2,0,0,2,1,2,0,2,2,2,2,2,2,2,2,0,0,2,2,2,0,2,0,2,2,2,2,2,2,2,2,1,2,1,2,1,2,0,2,2,1,2,0,2,2,2,1,2,2,2,2,2,0,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,1,2,0,2,2,2,2,1,2,2,2,2,2,1,2,2,2,0,0,0,2,2,2,0,0,2,2,2,2,1,1,2,0,2,0,2,1,2,2,2,2,2,0,2,1,1,0,2,0,0,2,0,2,1,1,1,2,2,0,2,2,2,2,2,2,0,0,0,0,1,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,1,2,1,2,2,2,2,2,2,1,2,1,1,0,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,1,2,1,2,2,1,2,0,2,2,0,2,0,0,2,2,2,2,2,2,2,2,0,1,2,2,2,2,0,2,1,2,2,2,1,1,2,0,2,2,2,2,2,2,1,2,2,2,2,0,1,0,2,0,0,2,2,0,0,1,1,2,2,1,2,2,2,2,2,2,0,0,1,2,0,2,2,1,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,1,2,2,2,2,2,2,2,2,0,1,0,2,2,2,1,2,2,2,2,2,2,0,1,2,2,2,2,2,2,1,2,2,1,2,2,0,1,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,1,2,2,1,2,1,2,0,2,2,1,1,2,2,2,2,0,1,2,2,0,2,2,2,2,2,1,0,1,2,2,2,1,0,2,2,2,2,2,0,2,2,2,2,2,0,2,1,2,0,2,2,1,2,2,2,2,1,0,2,2,0,2,2,2,2,2,2,1,0,1,0,0,2,0,1,2,1,2,1,2,2,2,2,2,2,2,2,2,1,2,2,0,1,2,0,2,2,2,2,0,2,2,2,0,0,2,2,2,2,1,2,2,0,2,1,2,1,2,0,2,2,2,2,2,0,2,2,2,2,2,2,1,2,2,2,1,2,2,2,0,2,1,2,2,2,2,2,0,2,0,2,2,0,2,1,2,2,2,2,1,1,2,2,2,2,1,2,2,2,1,2,0,2,2,2,0,2,0,2,2,2,2,0,2,2,2,2,2,2,2,2,1,2,2,2,2,0,2,2,2,2,2,2,0,2,1,2,0,2,2,0,2,2,2,2,2,2,0,0,2,0,1,2,0,1,2,0,2,1,2,2,2,2,2,2,2,2,1,1,2,2,1,2,2,1,2,0,2,2,0,2,2,2,1,1,1,2,0,2,1,2,2,1,2,0,2,1,1,1,2,2,2,2,2,0,2,2,1,2,2,0,1,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,1,2,0,2,2,2,2,2,2,1,2,2,1,2,2,2,2,2,0,1,2,2,1,1,0,2,2,2,0,1,2,2,2,2,2,2,2,1,2,2,2,0,2,2,1,2,2,2,2,0,0,1,2,0,2,2,0,1,2,2,1,2,2,2,2,2,2,2,2,2,0,1,0,0,2,2,1,2,2,2,2,0,2,2,2,2,2,2,1,2,0,1,2,2,2,0,2,0,2,1,2,2,0,2,2,2,0,2,0,2,0,2,0,2,2,1,2,2,2,1,1,1,2,2,2,2,2,0,2,2,1,2,2,2,2,2,2,2,1,2,2,2,2,2,1,2,2,2,2,2,1,2,2,2,2,2,2,0,2,0,1,2,0,2,2,2,2,2,1,0,2,2,0,1,0,2,2,2,1,2,1,2,2,2,2,2,2,0,2,1,2,1,2,2,2,2,2,1,2,2,1,1,2,2,1,2,2,1,0,0,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,1,2,2,1,2,2,2,2,2,2,2,2,1,2,0,2,2,2,1,0,2,1,2,2,2,2,1,2,2,2,2,1,1,2,1,2,0,2,2,2,2,2,2,2,1,0,2,2,2,2,2,1,2,2,0,2,2,2,2,2,2,2,1,2,2,2,0,2,2,2,2,0,2,2,1,2,1,2,2,2,2,2,2,2,1,2,0,1,2,2,2,2,0,0,2,2,1,2,1,2,2,2,2,2,1,2,2,2,0,0,2,0,2,1,2,0,2,2,0,2,2,2,2,0,0,0,2,1,2,2,2,1,0,2,1,2,2,0,2,2,2,2,2,2,2,1,0,2,0,2,0,0,2,1,2,2,2,2,2,2,2,2,2,2,0,0,2,2,0,2,2,0,2,1,2,2,0,2,2,2,0,0,1,2,0,2,0,2,2,2,2,0,2,2,1,2,2,2,2,2,2,0,2,2,0,2,2,0,0,2,2,2,0,2,2,2,1,2,0,2,2,0,2,2,1,2,2,2,2,0,2,0,2,2,0,2,2,1,2,2,2,2,2,1,2,2,1,2,0,2,2,2,0,0,1,2,2,2,1,0,2,2,2,0,2,1,2,2,1,2,2,1,2,1,1,0,2,0,1,2,2,1,0,1,1,2,2,2,2,2,2,2,2,2,2,2,0,1,1,2,2,2,2,0,2,1,2,2,2,2,2,2,0,2,1,2,2,2,0,0,2,0,2,1,2,2,2,0,2,2,1,2,0,2,0,2,0,2,2,2,2,2,2,2,0,1,2,2,2,2,2,2,2,2,0,2,2,2,1,2,2,2,0,2,2,2,0,2,0,2,2,1,2,2,1,2,1,2,2,0,2,0,2,2,1,2,0,1,2,0,2,2,1,0,2,2,2,2,2,2,2,2,0,0,0,2,2,2,2,0,2,0,2,0,2,2,2,2,2,2,2,1,2,0,0,2,2,2,2,2,2,2,0,0,1,2,2,1,2,2,2,2,2,2,2,2,0,2,1,2,2,1,2,1,2,1,2,2,2,2,2,2,0,2,1,1,2,2,0,0,2,0,2,1,2,2,2,2,2,2,0,2,0,2,2,2,2,2,2,0,2,1,2,1,1,1,2,2,2,2,2,1,2,2,1,2,2,2,0,2,2,2,1,2,2,2,1,2,2,2,2,2,2,2,0,2,1,2,2,2,2,2,2,2,1,2,2,2,2,0,2,2,1,2,2,2,0,0,0,2,2,2,1,2,0,2,2,2,0,1,2,2,2,0,2,1,2,2,1,2,2,2,2,2,1,0,2,2,2,2,2,0,0,2,1,2,2,0,2,2,2,2,2,2,1,0,0,0,0,2,2,0,2,1,2,2,2,2,2,2,2,2,2,2,0,0,2,2,1,1,2,1,2,2,2,2,2,0,2,2,1,2,2,2,1,2,1,2,2,2,2,1,2,2,2,2,2,2,1,2,2,1,2,2,2,2,2,0,2,2,2,2,2,2,2,2,0,2,1,0,2,0,2,2,1,2,2,2,2,1,2,1,2,0,0,2,0,0,2,1,2,2,1,0,2,2,2,0,0,2,2,2,0,2,1,2,2,2,1,2,2,0,2,2,2,1,2,2,2,2,2,0,2,0,1,0,2,0,2,2,0,0,1,1,1,2,2,2,2,2,2,2,2,2,0,2,2,0,1,2,0,2,2,0,2,2,2,2,2,2,2,2,2,2,0,0,2,2,1,2,2,0,2,0,2,2,1,0,2,2,1,1,1,2,2,2,2,2,2,2,2,1,2,2,1,0,2,2,0,2,2,0,2,2,1,2,2,0,1,2,2,2,1,2,2,2,1,2,1,0,2,2,2,2,1,2,2,2,2,1,2,2,2,2,2,2,2,2,2,1,2,2,1,2,2,2,0,0,1,2,2,2,0,0,1,2,2,2,0,1,2,2,2,1,2,2,2,2,0,2,2,1,2,1,2,2,2,0,0,2,1,1,1,1,2,2,2,1,2,2,2,2,2,2,2,2,0,0,1,2,0,2,2,0,2,2,2,2,2,2,2,2,0,2,2,2,2,2,0,2,2,1,2,0,2,2,1,1,2,2,0,2,2,2,0,2,1,2,2,2,2,1,2,1,1,2,2,2,2,2,2,0,2,2,0,2,2,2,1,2,2,2,1,2,0,2,2,2,2,2,2,0,2,2,0,2,1,2,2,1,2,0,2,0,2,2,2,2,2,0,2,2,2,0,2,2,2,2,2,2,2,2,2,2,0,2,2,2,1,1,2,0,2,1,2,0,2,2,2,2,2,0,2,0,1,1,2,0,2,2,1,1,2,1,0,2,2,1,2,2,2,2,1,2,2,2,0,2,1,2,1,1,2,0,2,0,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,1,2,2,1,1,2,2,1,0,0,2,2,2,0,2,2,0,2,1,2,0,1,1,2,2,0,2,2,2,2,2,0,2,2,2,2,2,2,0,0,2,2,2,2,2,1,2,2,1,2,2,0,2,1,2,2,1,2,2,2,1,2,2,2,2,2,1,2,2,1,1,2,2,1,0,0,2,0,2,0,2,1,2,2,2,0,2,2,0,2,2,2,1,2,2,2,2,2,2,2,1,0,0,2,0,1,2,2,1,2,1,2,2,2,2,2,2,2,2,0,2,2,0,1,0,0,2,2,0,2,1,2,0,2,2,2,2,2,2,1,2,1,2,2,2,0,0,2,0,2,1,2,2,2,1,2,2,1,0,1,2,2,2,0,2,2,0,2,1,2,0,0,2,2,2,0,2,2,0,2,2,2,2,2,1,2,2,2,2,2,2,1,2,0,2,0,2,2,0,2,2,1,2,0,2,2,1,2,0,2,1,0,2,2,0,2,2,2,2,2,1,2,2,0,0,1,2,2,2,0,1,1,2,2,2,2,0,2,2,2,0,2,0,2,2,1,2,2,0,2,2,0,2,2,0,0,2,2,1,1,0,1,2,2,2,2,2,1,2,2,2,0,2,1,2,2,2,1,0,2,1,2,2,2,2,2,2,2,2,1,2,2,0,2,2,2,2,2,2,2,1,2,2,2,1,2,2,0,2,1,2,0,2,0,2,2,0,2,1,2,0,1,2,2,2,0,2,2,0,2,2,0,2,2,1,1,2,2,1,0,2,2,2,1,2,0,1,2,2,2,2,1,2,0,2,2,1,2,0,2,0,0,2,0,1,2,2,2,2,0,0,2,2,2,0,0,2,0,2,0,1,2,2,2,2,1,1,2,0,2,1,2,1,0,2,0,2,2,2,2,0,0,2,2,0,2,2,2,1,2,0,2,2,2,1,2,2,1,2,2,2,0,1,2,0,2,2,1,1,2,0,2,1,2,2,2,2,2,2,0,2,2,1,2,2,0,1,2,1,2,0,2,2,0,0,2,2,0,2,0,2,0,2,0,2,2,1,2,1,2,2,0,1,2,2,0,2,2,2,2,2,1,2,2,2,2,2,2,1,2,2,2,2,1,2,1,1,2,1,2,2,2,2,0,2,2,2,2,1,2,1,0,2,2,2,2,0,2,2,1,2,2,0,2,2,0,2,0,2,2,2,1,2,2,2,0,1,0,1,2,2,2,2,2,2,1,2,2,1,2,1,0,0,2,1,1,2,2,1,1,1,0,2,2,0,2,2,2,2,2,2,1,2,2,1,2,2,2,2,2,0,2,0,2,2,2,2,2,2,2,2,1,0,2,2,1,0,2,0,2,0,2,2,2,1,2,2,0,2,2,2,0,2,0,2,2,1,2,2,2,0,0,1,2,2,1,2,2,2,2,2,1,2,2,2,2,2,2,0,2,2,2,2,2,2,2,1,2,0,2,2,1,2,0,2,2,2,2,0,2,1,1,2,2,1,2,1,2,2,2,1,2,2,1,0,0,2,2,2,0,1,1,2,2,2,2,2,0,1,2,2,2,1,2,2,0,2,2,1,2,0,0,1,2,2,1,2,1,1,2,0,1,2,2,0,2,2,2,2,0,2,0,0,0,0,2,2,1,2,2,2,2,1,2,2,2,2,2,2,1,2,0,1,2,2,1,0,2,2,2,0,2,2,0,2,2,2,1,0,1,2,1,2,0,2,2,1,2,2,2,0,0,1,2,2,1,2,2,0,2,2,0,2,2,1,0,2,2,0,1,2,2,2,1,2,0,1,2,0,2,2,1,2,1,2,2,1,2,2,2,1,2,2,2,2,2,2,2,2,1,2,2,1,2,2,1,2,1,2,0,0,0,2,2,2,1,0,0,1,2,2,2,0,1,2,2,2,2,2,2,2,0,2,2,2,2,2,2,0,0,1,0,2,2,1,2,2,1,2,1,2,2,2,2,0,1,1,2,0,2,1,2,1,2,2,2,2,2,2,1,2,2,0,2,2,0,2,2,1,2,2,2,2,0,2,2,2,2,1,1,2,2,2,0,2,2,2,2,2,2,2,0,0,2,2,0,2,2,0,2,2,0,2,2,2,2,2,2,2,2,2,0,2,0,2,2,1,2,2,2,2,0,2,1,2,2,1,2,2,2,1,1,2,2,2,2,2,2,2,0,1,2,2,0,2,0,2,2,2,2,1,2,2,2,2,1,1,0,0,2,0,2,2,0,2,1,2,2,2,2,1,1,1,2,2,2,2,0,0,1,0,2,2,2,1,2,2,2,2,0,2,2,0,2,2,2,1,0,2,2,2,2,1,2,2,2,2,0,2,2,2,2,0,2,2,0,1,2,2,2,0,2,2,2,1,2,2,2,0,2,2,0,2,1,1,2,0,2,1,2,0,2,2,2,2,0,2,2,2,2,2,0,2,2,1,2,2,2,0,1,2,0,2,2,2,1,2,2,1,2,2,2,2,2,2,2,0,2,2,2,1,0,2,1,2,2,2,2,2,2,1,2,1,1,0,2,2,2,2,0,0,1,2,2,2,1,2,1,0,2,0,2,2,2,2,0,2,2,1,2,0,2,2,2,0,1,2,1,0,0,1,2,2,2,2,2,2,2,2,0,2,2,0,0,2,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,0,2,2,2,2,1,2,2,2,1,0,1,2,0,2,1,0,2,2,2,1,2,2,1,0,2,2,0,2,2,1,2,2,0,2,2,2,1,2,2,0,0,2,1,2,1,2,1,1,2,2,2,2,2,2,0,2,2,0,2,0,2,0,0,2,0,0,2,0,2,2,0,1,2,1,1,1,1,2,2,2,2,1,1,2,2,2,2,0,2,2,2,1,2,0,2,2,0,2,2,0,2,0,2,0,0,2,1,2,0,1,1,1,1,2,2,2,2,2,1,2,2,2,0,2,2,2,2,1,0,1,2,1,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,0,2,0,2,0,2,2,0,0,2,2,2,1,2,2,2,2,1,1,2,1,2,0,2,2,1,0,2,2,0,2,2,0,2,2,2,2,2,0,1,2,2,2,2,2,0,2,1,2,0,1,2,2,2,2,2,2,0,2,2,2,2,0,2,2,1,2,0,1,0,1,2,2,0,1,2,2,1,2,0,2,0,2,0,1,0,2,2,2,2,0,2,0,2,1,2,0,0,2,1,2,2,0,2,1,1,0,2,0,2,2,2,2,2,0,1,2,2,0,2,2,1,2,2,2,0,0,2,2,0,2,0,0,2,2,2,1,2,2,2,2,1,2,1,2,1,0,2,2,1,2,0,1,2,0,2,2,0,1,2,2,0,1,0,0,2,2,2,0,2,2,2,2,2,1,0,0,2,2,1,2,2,0,2,2,0,2,2,2,2,2,2,0,2,2,1,2,2,2,2,0,2,0,2,2,0,2,1,2,2,1,2,2,2,2,0,2,2,1,1,2,2,2,0,0,2,2,0,2,0,2,1,2,1,0,1,2,2,2,2,2,2,0,2,0,2,1,0,2,1,2,2,2,2,2,2,1,0,1,1,2,0,2,1,1,0,2,2,1,2,2,1,2,0,2,2,1,0,2,1,2,2,1,2,1,2,1,2,2,2,2,1,2,2,2,1,0,2,2,0,1,0,2,2,2,2,2,2,0,2,2,0,2,0,2,2,2,2,0,2,0,2,0,2,0,1,2,2,2,0,2,2,2,2,2,0,2,2,1,1,2,2,0,1,2,0,2,1,2,1,0,2,2,2,2,0,2,1,2,2,1,2,2,2,2,1,2,1,0,2,2,2,2,1,2,2,1,2,2,2,2,0,2,2,0,1,2,2,2,0,0,0,1,2,1,2,2,1,2,2,2,2,2,2,1,1,0,1,2,2,2,0,0,1,1,0,2,2,0,2,2,2,2,1,2,0,1,2,0,2,0,1,1,2,0,2,2,2,2,2,2,0,2,1,2,1,1,2,2,2,0,0,0,2,0,2,2,1,1,2,2,0,0,1,1,1,2,1,1,2,1,2,1,2,2,0,0,2,2,0,2,2,1,2,2,1,2,2,1,1,2,2,0,1,2,2,2,2,2,0,2,2,0,2,2,0,2,2,2,2,2,2,2,2,2,2,2,1,0,2,0,2,2,1,2,2,0,0,2,0,2,0,2,0,2,2,2,2,2,2,0,1,0,2,1,2,1,2,2,2,2,2,2,2,0,2,0,2,2,0,2,1,0,1,2,2,2,2,2,2,2,0,2,2,2,1,0,1,1,2,0,1,1,2,1,2,1,2,2,2,2,0,2,2,2,2,0,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,1,0,1,2,1,2,2,2,2,1,2,2,1,1,2,2,0,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,1,2,2,2,1,1,1,2,2,2,1,2,1,2,2,1,2,2,2,0,2,2,0,0,0,0,2,2,0,0,2,2,1,1,1,2,0,2,0,2,1,2,2,2,1,2,2,0,2,1,2,2,2,2,1,2,2,0,2,1,2,0,1,1,1,2,2,2,1,2,0,2,2,2,2,2,1,2,2,2,2,0,0,2,0,1,0,0,2,0,2,2,2,2,2,2,0,2,0,2,2,1,2,2,2,1,2,2,2,2,2,2,2,0,2,2,0,0,2,2,1,2,0,2,2,0,2,1,2,0,1,1,2,2,0,2,2,2,2,2,0,2,2,1,1,2,2,0,2,2,2,2,2,2,0,2,2,2,2,2,1,1,2,2,2,0,2,2,2,0,1,2,0,2,1,0,2,2,0,0,2,2,0,2,0,2,0,2,0,0,0,2,2,2,0,1,1,0,2,1,2,2,1,2,1,2,2,2,2,0,2,2,0,2,2,2,1,1,0,0,1,2,2,0,2,2,1,2,2,2,1,2,0,0,0,1,2,1,2,1,2,1,2,2,2,2,2,2,2,2,1,0,2,2,0,1,1,0,2,1,2,2,0,2,2,2,1,1,0,1,1,2,1,2,2,1,2,0,2,0,0,1,2,2,0,2,2,2,2,2,0,2,2,0,2,2,2,2,2,2,1,2,0,2,2,1,1,0,2,2,0,1,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,0,2,0,2,0,1,2,1,2,0,1,2,2,2,2,1,0,0,1,2,0,2,0,1,2,0,2,2,1,2,2,1,0,2,1,2,2,1,0,0,2,0,2,0,1,2,2,0,2,1,2,0,2,0,1,2,2,1,0,2,1,2,1,2,2,2,2,0,2,0,2,2,2,2,2,0,2,0,0,2,2,2,2,2,1,2,2,0,0,1,1,0,2,1,2,2,0,2,0,2,0,1,1,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,1,0,2,2,2,1,2,0,2,2,0,2,2,0,2,2,2,2,2,2,0,2,2,2,2,1,0,0,1,2,2,0,1,2,2,1,0,0,2,0,2,2,0,0,2,2,2,1,2,1,0,2,0,2,1,0,2,0,2,2,2,2,2,1,0,2,2,1,2,2,1,1,0,2,2,2,1,2,2,1,2,2,2,2,0,1,2,0,1,1,0,2,1,2,2,2,2,2,2,1,2,1,2,2,2,2,2,1,1,1,0,2,2,2,2,0,2,0,2,2,0,1,1,0,2,1,0,2,0,2,2,2,2,1,1,2,2,1,2,2,2,2,2,1,2,2,2,2,2,2,2,0,2,1,2,1,2,1,2,1,0,2,2,1,1,0,2,2,0,2,1,2,1,1,2,1,0,1,0,2,2,2,2,2,0,2,1,0,2,0,2,0,1,2,2,2,2,2,2,0,0,2,2,2,2,0,2,1,2,2,2,2,0,1,0,1,2,2,2,2,2,1,2,1,2,0,2,2,2,1,2,2,2,1,0,1,0,1,2,1,0,2,1,2,2,2,2,2,2,0,2,2,2,1,2,2,2,1,1,2,2,2,0,2,2,1,1,1,2,1,2,1,2,0,2,1,2,2,0,2,0,2,0,0,1,2,2,1,2,2,2,2,2,0,2,2,2,2,2,2,0,2,2,1,2,0,2,2,1,1,2,2,2,2,2,2,2,2,2,2,0,2,0,0,2,0,2,2,2,2,2,0,1,2,2,1,1,2,2,2,2,0,2,1,2,2,2,1,0,2,2,2,2,2,0,1,2,0,2,2,2,2,1,1,0,0,2,1,2,1,1,0,2,2,2,2,1,2,2,1,2,0,2,1,0,2,0,0,0,0,0,2,2,2,2,2,2,2,2,1,2,0,2,2,2,2,1,0,2,1,1,2,1,2,2,2,1,1,2,0,2,2,1,2,2,0,0,2,0,2,0,2,2,0,1,2,2,1,2,2,1,2,2,0,2,2,2,1,2,2,0,2,2,1,2,2,2,0,0,0,1,2,2,2,1,2,2,2,0,2,0,2,1,2,2,2,2,0,2,2,2,2,0,2,0,2,2,0,2,0,2,2,0,1,0,2,2,0,1,2,2,2,0,2,0,2,2,1,2,2,0,2,1,2,1,0,1,0,2,2,1,2,1,0,2,2,1,2,2,2,2,2,2,0,0,0,1,1,0,1,1,2,2,2,1,2,2,2,2,1,2,2,2,2,2,2,1,1,0,0,0,2,1,2,2,2,0,1,2,2,2,0,1,2,2,0,2,2,1,2,2,2,0,1,1,2,2,0,2,2,0,2,2,0,2,2,0,1,2,2,1,1,2,2,2,0,2,2,0,0,2,2,2,0,2,0,2,2,1,2,0,2,0,0,2,1,2,1,1,2,2,0,0,0,1,2,1,1,2,1,2,1,0,2,0,2,2,2,1,0,0,2,2,2,1,0,2,1,2,2,0,2,1,0,1,1,0,1,2,1,1,2,0,1,2,0,1,2,2,1,2,0,2,0,2,0,0,2,1,2,2,2,2,2,1,2,2,2,2,0,2,1,2,1,1,2,0,1,0,0,1,0,0,2,2,1,1,0,2,0,2,1,0,1,2,2,2,2,1,2,2,2,0,1,1,2,2,2,2,2,0,2,2,2,2,2,0,0,2,2,1,2,2,0,2,1,2,0,1,0,0,2,2,2,2,2,2,2,0,2,0,2,0,1,2,2,2,0,2,2,2,0,2,0,1,0,1,2,2,2,2,1,2,0,0,2,0,0,0,0,1,2,1,2,1,2,2,1,2,2,1,2,2,0,0,1,1,1,2,2,2,1,1,1,2,1,2,2,2,2,2,0,2,0,2,1,0,2,0,2,0,2,0,2,0,2,2,2,2,0,2,2,2,2,0,2,0,1,0,1,2,2,0,2,2,0,2,2,2,1,1,0,0,0,2,0,1,2,2,2,0,2,0,0,0,2,2,1,2,2,0,2,2,0,2,2,2,0,2,2,1,1,2,2,2,1,2,1,1,2,1,2,2,2,0,2,2,2,2,2,0,2,1,2,2,2,1,0,1,2,2,2,2,1,2,0,1,1,2,1,2,2,0,1,1,2,0,1,2,1,1,2,2,2,1,1,2,2,2,2,0,2,0,1,1,1,2,0,2,0,0,1,1,0,2,0,2,2,2,2,2,0,2,1,0,0,2,2,2,1,0,2,0,2,0,2,2,2,2,2,2,2,2,1,2,2,1,2,1,0,0,0,0,2,2,1,0,0,2,0,1,1,2,2,2,1,0,2,0,2,0,2,1,1,2,2,2,0,2,2,2,2,2,0,2,2,1,0,2,2,0,2,2,0,2,0,2,2,2,2,2,2,2,0,2,2,2,2,0,2,0,2,1,2,2,1,1,0,0,2,2,0,1,1,2,0,0,0,2,0,2,0,1,1,2,2,1,1,1,1,0,2,0,2,0,2,2,2,2,2,1,2,2,1,0,2,1,2,2,1,1,0,1,1,2,1,0,2,2,2,2,1,2,2,2,2,1,0,2,1,1,2,1,2,0,2,2,2,2,0,2,2,2,1,1,2,2,0,1,2,2,1,1,2,2,0,2,2,2,1,1,2,2,0,2,1,0,2,1,2,2,2,0,1,2,2,2,0,2,2,2,2,2,0,2,2,2,1,2,2,0,0,2,0,2,1,2,1,2,2,1,2,2,0,0,2,2,2,1,2,1,2,2,0,2,2,1,1,1,2,2,1,2,0,2,0,2,1,2,2,2,1,2,2,2,0,1,2,2,2,0,2,1,2,1,0,2,1,2,2,1,2,2,1,0,1,0,1,2,0,1,2,0,2,2,1,2,2,2,0,2,0,2,0,0,1,2,1,1,1,1,2,1,2,1,2,2,2,2,1,2,0,2,2,0,2,0,1,2,1,1,1,1,2,2,1,2,1,2,2,2,0,0,0,2,0,2,2,0,2,2,2,1,0,1,2,2,0,2,2,2,2,2,2,2,2,0,2,2,2,1,0,2,0,2,0,2,0,2,0,0,2,2,2,2,1,2,2,2,2,2,2,1,2,2,0,0,0,2,2,2,0,1,0,1,2,0,1,2,1,2,1,0,0,2,1,2,0,0,2,2,2,1,2,1,0,2,1,0,2,0,2,1,0,2,1,1,1,2,2,2,1,2,2,2,2,1,2,2,2,2,0,2,0,2,2,2,2,1,0,2,2,2,2,2,2,2,2,2,1,2,0,2,2,1,2,2,0,0,1,1,1,1,2,2,2,2,1,2,0,0,0,1,2,2,1,0,2,0,2,1,2,0,2,1,0,2,1,2,2,0,2,2,1,2,2,2,0,2,2,1,2,2,1,2,1,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,0,0,2,2,1,2,2,2,2,0,1,1,1,2,0,0,2,1,0,0,2,0,1,1,2,2,2,1,1,2,1,2,2,2,2,0,0,2,1,2,2,1,0,0,2,2,2,2,2,2,2,0,2,1,2,2,2,0,2,1,2,1,0,1,0,0,2,2,0,2,0,2,1,2,2,2,2,1,2,0,2,0,1,2,2,2,2,2,1,2,2,2,2,2,1,2,2,0,1,2,0,1,2,2,1,2,1,2,1,2,0,0,2,1,2,1,2,2,0,2,2,0,2,2,2,1,2,2,2,0,2,2,2,1,2,0,1,2,1,1,2,0,0,0,2,2,2,2,0,2,1,1,2,1,1,2,0,2,2,0,2,0,0,2,1,0,2,2,2,1,1,1,2,1,2,2,0,0,1,2,0,2,2,2,2,2,0,2,2,2,0,2,2,1,1,2,2,2,0,2,0,2,2,2,0,2,2,2,2,2,2,2,2,0,2,1,1,0,1,2,1,2,1,2,2,2,2,1,2,0,2,2,2,2,0,1,2,2,0,0,2,2,2,2,2,1,2,2,1,1,0,2,2,1,1,2,0,2,2,2,2,0,2,2,2,1,2,2,2,2,2,0,2,2,0,2,2,2,2,2,2,2,2,0,2,2,1,2,2,1,2,0,1,1,2,2,2,2,0,2,1,1,2,0,2,0,1,2,2,0,2,0,2,1,1,1,2,0,1,0,0,1,2,2,1,0,2,1,1,2,2,2,1,0,2,0,0,2,1,2,2,0,2,0,0,2,2,0,0,2,1,1,2,2,0,2,2,2,2,2,2,2,2,1,0,1,0,2,2,2,2,2,2,2,2,2,2,0,2,0,2,1,0,2,1,2,2,1,0,1,2,2,2,1,2,2,2,2,2,2,2,1,2,0,2,2,1,2,0,2,0,1,1,2,2,0,2,2,2,2,2,1,2,2,1,0,2,2,2,0,2,2,2,2,2,1,1,0,2,1,2,2,2,1,2,2,0,2,0,2,1,2,2,1,2,1,1,2,2,2,1,2,1,2,1,1,2,0,0,1,2,1,0,1,2,1,0,0,2,2,2,2,1,0,2,1,0,2,1,2,2,0,1,1,0,0,2,1,2,0,0,2,2,1,2,2,2,1,2,2,2,2,2,1,0,2,0,1,0,2,2,2,2,2,2,2,1,2,2,1,2,2,1,2,2,1,1,1,2,1,0,2,2,1,1,0,2,1,0,1,1,2,2,0,2,2,1,2,2,2,2,2,1,2,2,1,2,2,2,2,2,2,2,2,1,2,2,2,1,0,2,2,2,2,2,2,2,2,1,0,2,0,0,1,2,2,2,2,0,2,2,2,2,1,2,1,0,2,2,2,1,2,1,1,1,0,2,2,0,2,2,1,1,2,0,0,2,2,1,2,1,1,0,0,2,1,2,2,0,2,0,0,1,1,1,2,2,0,1,1,2,2,2,2,2,0,2,2,2,2,2,2,0,1,0,0,0,0,1,2,2,2,2,2,2,2,1,1,2,1,2,1,0,2,0,1,1,1,0,1,1,2,2,0,1,0,1,1,1,1,0,0,2,0,2,2,1,2,0,2,1,2,2,1,2,2,2,2,0,2,2,1,2,2,2,0,2,2,1,0,2,1,2,2,2,0,1,2,2,1,2,0,0,1,2,2,0,2,2,2,2,1,2,0,2,2,2,2,2,1,1,1,0,0,1,1,2,1,2,1,1,1,0,2,1,0,0,0,2,1,0,0,0,2,2,2,1,2,2,2,1,0,2,1,1,1,2,2,0,0,0,1,2,2,0,2,2,1,2,1,2,1,2,0,0,1,1,2,0,2,0,2,0,2,2,2,1,1,2,0,2,2,2,2,1,1,0,2,0,2,0,1,2,2,2,0,0,0,0,2,0,1,2,0,2,2,2,2,0,2,2,1,2,1,2,0,2,2,0,2,2,1,2,0,0,2,2,2,0,2,2,1,2,2,2,0,2,1,1,0,2,0,2,1,2,2,2,2,1,2,2,2,2,0,0,2,0,2,2,1,0,0,1,1,2,0,2,2,0,1,0,2,0,1,0,0,2,0,2,2,1,0,2,1,2,0,2,2,2,2,2,1,0,1,0,2,2,1,2,2,0,0,2,1,2,0,2,1,2,0,2,1,2,2,0,2,1,0,1,2,2,2,0,2,2,2,0,1,2,1,2,0,0,2,2,1,2,2,0,1,2,0,2,1,0,2,2,0,2,0,0,0,2,2,1,2,1,2,2,2,0,1,0,2,2,2,2,2,1,2,2,1,2,0,1,1,2,2,2,1,2,2,2,2,2,1,1,1,0,0,2,1,2,0,2,2,0,2,1,2,2,1,2,0,1,0,1,2,2,2,0,2,0,2,2,2,2,1,1,1,2,0,2,0,0,2,0,0,1,0,1,0,0,1,2,2,2,2,1,2,2,1,1,0,0,1,2,0,2,2,1,1,2,2,1,0,2,0,2,2,2,0,1,2,0,0,2,2,2,2,0,2,0,2,2,2,0,1,2,2,2,2,0,2,2,0,2,2,2,0,0,1,2,1,2,1,0,0,2,2,0,1,2,0,0,2,2,2,0,2,1,2,1,0,2,2,2,2,0,2,2,2,2,0,2,2,2,2,0,1,2,0,2,1,2,0,2,0,0,2,2,2,1,1,2,2,0,2,1,2,0,1,2,0,2,2,1,2,2,2,1,0,2,1,2,2,2,1,0,2,1,1,0,2,2,1,2,1,1,0,2,2,0,1,2,2,1,2,1,2,1,2,0,2,1,1,2,2,2,0,1,2,2,0,1,2,2,2,2,1,2,1,1,1,0,2,0,2,0,2,1,2,1,2,2,2,0,1,2,1,2,1,1,2,1,2,2,1,1,2,0,1,2,2,1,1,0,0,2,1,0,1,2,2,2,2,0,2,1,2,2,0,1,1,2,2,2,2,1,2,2,0,2,1,1,2,2,2,1,2,2,2,2,2,2,2,1,0,0,0,2,1,1,2,2,2,2,2,0,2,0,1,2,2,2,2,0,2,2,1,0,0,0,0,0,0,2,0,0,1,0,0,0,0,0,1,2,2,1,2,0,2,1,1,0,2,0,2,2,2,0,0,0,2,1,1,2,0,2,0,2,1,2,1,1,0,2,2,2,2,2,0,1,0,1,0,1,1,0,2,0,2,2,2,2,2,2,1,2,1,2,0,0,2,1,0,0,0,2,2,1,0,2,1,1,2,1,1,1,2,1,0,0,2,0,2,2,2,2,2,1,2,0,1,2,0,2,2,0,2,2,2,2,1,2,2,2,2,2,0,2,2,2,0,2,1,1,2,1,2,2,0,1,2,2,2,0,2,1,2,2,2,2,2,2,0,1,2,2,0,1,0,1,0,1,2,2,1,1,1,0,1,1,2,1,0,0,1,0,0,2,0,2,1,0,2,1,2,1,2,2,2,1,0,1,2,2,2,0,2,1,0,2,1,1,1,1,0,2,0,2,1,1,0,0,0,1,2,1,2,1,2,0,2,2,2,2,1,2,0,2,1,2,2,0,0,0,2,0,1,2,1,2,1,2,1,1,2,1,2,2,1,0,1,2,2,2,2,1,2,2,0,0,2,2,0,2,2,1,2,2,1,2,2,0,1,2,2,2,0,2,1,2,0,2,0,0,2,2,2,2,0,0,1,2,2,1,2,2,2,2,2,2,2,2,1,0,2,2,1,1,0,2,2,1,2,2,1,1,1,0,0,0,1,2,0,1,1,0,2,1,2,1,1,1,2,2,2,1,2,1,0,0,1,1,1,2,0,0,1,1,2,2,0,0,1,1,0,2,1,2,2,1,0,1,2,0,1,1,2,2,2,2,2,2,2,1,1,2,0,2,0,0,2,2,1,2,2,2,1,1,2,2,1,2,2,2,0,1,0,1,1,0,0,0,2,1,2,1,2,0,2,0,2,2,2,2,2,0,2,2,1,2,0,1,0,2,2,0,1,2,1,2,1,2,1,2,0,1,0,2,1,1,0,2,2,2,2,0,2,2,0,2,0,0,2,1,2,2,2,1,2,0,1,1,1,2,0,2,0,2,2,2,2,0,2,1,0,2,0,2,2,1,2,2,1,1,2,0,2,2,1,1,1,0,0,2,1,2,0,1,2,2,0,0,1,0,1,2,1,2,0,0,2,2,0,1,1,1,2,1,2,1,2,2,2,0,1,2,0,2,0,2,2,2,2,0,2,2,1,0,2,2,0,1,1,0,1,0,2,2,0,0,0,1,2,2,2,1,1,1,1,1,1,2,2,2,2,0,2,2,0,2,2,0,0,2,2,1,2,2,2,2,1,2,1,0,0,2,1,2,0,1,0,0,2,0,2,2,2,1,1,2,1,0,2,1,2,2,2,0,1,2,0,0,1,2,0,2,2,1,1,0,1,2,0,2,0,1,2,2,1,1,2,1,0,1,2,2,2,0,1,2,2,0,1,2,0,1,0,0,0,2,1,0,1,2,0,2,1,2,1,1,0,2,2,1,2,2,2,2,2,0,2,2,2,2,1,2,0,2,2,2,1,0,2,1,2,0,1,0,0,2,1,1,1,0,1,0,0,1,1,0,2,2,2,1,2,1,0,1,2,0,2,2,1,2,2,0,2,2,0,2,1,2,2,2,2,1,2,2,1,2,0,2,2,0,1,1,0,2,0,2,1,2,2,2,2,0,2,1,0,2,2,1,0,1,2,0,0,0,1,0,1,1,1,2,2,1,1,1,2,2,1,0,0,0,1,1,1,0,1,2,1,1,2,1,2,0,2,0,1,0,1,2,2,2,2,1,1,0,1,2,0,0,0,2,1,2,2,2,2,0,1,2,2,1,1,0,2,1,2,1,2,2,2,2,0,2,2,2,2,0,0,2,1,2,1,2,0,2,2,2,0,0,1,1,0,0,2,1,1,0,0,2,2,2,2,2,0,2,2,2,0,2,2,2,2,0,2,2,0,2,2,2,0,2,2,0,0,2,1,2,0,2,1,2,2,0,0,2,1,1,1,0,0,0,2,2,2,1,0,2,0,0,1,0,2,2,1,2,1,2,0,0,0,2,0,0,1,1,1,2,1,2,2,2,0,1,0,2,0,2,0,2,1,0,2,1,2,2,1,2,0,1,1,2,0,0,2,2,1,2,1,1,0,1,0,2,1,2,1,0,1,2,1,2,1,0,2,1,2,2,2,2,2,0,0,2,0,2,0,2,2,0,1,1,1,0,1,2,0,2,1,0,2,0,2,2,0,1,0,1,2,2,0,0,2,2,0,1,1,2,2,2,1,2,2,2,2,2,1,2,2,2,0,2,2,1,2,2,2,2,2,2,1,0,2,2,2,2,0,0,2,2,2,2,2,0,2,2,0,2,0,2,1,2,2,0,0,0,1,2,1,2,0,2,0,1,1,2,1,0,0,0,2,0,1,0,1,1,2,2,1,2,0,2,2,0,2,1,0,0,2,0,0,2,0,0,2,2,0,2,2,0,0,1,2,2,2,2,1,0,0,1,1,1,0,0,2,2,2,1,2,2,2,0,1,2,2,2,0,0,2,2,0,2,0,2,0,0,1,2,0,0,0,1,2,2,2,1,1,0,2,0,1,0,2,1,0,1,0,0,0,2,2,2,2,2,2,2,1,2,2,0,0,1,2,2,0,2,0,2,0,2,2,2,0,2,2,2,1,2,2,0,1,1,2,0,2,2,2,2,0,1,2,2,2,0,1,1,2,1,0,2,2,2,2,2,1,2,2,1,2,0,2,1,0,2,0,1,1,2,0,0,1,0,2,0,2,1,2,0,1,2,0,2,1,2,2,0,0,2,0,0,1,2,1,2,2,2,2,0,0,1,1,1,1,2,2,1,2,2,2,2,2,1,2,2,0,2,1,2,1,2,1,2,2,2,1,2,0,2,2,0,2,1,1,1,2,2,2,2,2,2,0,2,2,2,2,0,0,2,0,2,0,2,2,2,2,2,2,2,2,2,2,0,2,0,0,2,2,2,1,2,2,0,1,2,0,2,0,0,2,1,2,2,2,1,2,1,1,2,0,0,2,0,2,1,2,0,1,0,1,2,1,2,0,0,2,0,1,2,1,2,1,1,2,0,0,0,2,0,0,0,2,2,2,0,2,0,0,0,2,2,0,2,1,2,2,0,2,2,2,2,1,2,1,2,2,2,0,2,1,1,2,1,0,2,2,1,2,2,2,2,2,1,0,0,0,2,2,0,0,1,1,1,2,0,0,2,0,2,1,0,2,2,0,1,0,1,2,0,2,2,1,0,2,2,2,2,2,0,2,2,2,2,2,0,2,2,0,2,1,0,0,0,2,2,1,2,1,2,1,2,2,0,2,2,2,2,1,0,2,0,0,2,2,1,2,1,2,2,1,1,2,0,2,2,2,2,2,0,2,0,0,2,2,1,1,2,2,2,2,0,1,2,2,0,1,1,0,2,1,2,1,0,0,2,2,0,0,2,0,1,0,2,2,2,1,1,2,2,1,0,0,2,0,2,1,2,1,2,1,0,2,0,1,1,2,2,2,2,2,2,2,0,1,2,1,2,0,2,0,1,1,0,2,1,2,0,2,2,2,0,2,0,2,2,1,2,1,0,2,2,1,0,2,0,0,2,1,0,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,0,0,2,1,2,0,0,2,1,1,0,0,2,2,1,0,2,1,0,2,2,2,0,1,2,0,1,2,1,1,0,2,0,0,1,0,0,2,2,1,0,1,2,2,2,1,0,0,1,1,2,0,2,0,1,1,2,1,0,0,2,2,2,2,0,2,2,1,2,1,0,0,1,2,2,2,2,2,1,0,2,2,2,2,0,2,2,1,2,0,2,2,0,2,2,2,2,2,0,1,1,1,0,1,1,1,0,1,2,0,2,2,2,2,1,0,1,0,2,0,0,1,0,0,2,2,0,0,2,0,2,2,1,0,1,2,0,1,1,0,1,1,0,0,0,2,0,0,0,0,0,0,0,0,0,0,1,0,0,0,2,1,0,2,2,1,0,0,2,0,1,0,2,1,1,1,2,2,0,1,0,2,2,0,2,2,1,1,1,2,0,0,1,2,0,0,2,2,2,1,0,1,2,2,0,1,2,2,1,2,2,0,1,2,2,2,2,1,1,0,1,0,2,0,0,2,1,1,0,2,1,2,0,1,0,1,1,0,0,0,2,0,2,1,1,1,1,0,1,1,2,1,1}
	var width int = 25
	var height int = 6
	var stats = map[int]layerStats{}

	var layer int
	for i := range rawDigits {
		if i % (width * height) == 0 {
			layer++
			stats[layer] = layerStats{layer, 0, 0, 0, make([]int, width*height)}
		}
		tempLayer := stats[layer]
		tempLayer.data[i%(width * height)] = rawDigits[i]

		switch rawDigits[i] {
		case 0:
			tempLayer.SetZeroes(stats[layer].zeroes + 1)
		case 1:
			tempLayer.SetOnes(stats[layer].ones + 1)
		case 2:
			tempLayer.SetTwos(stats[layer].twos + 1)
		}
		stats[layer] = tempLayer
	}

	var lowestZeros, lowestLayer int
	lowestZeros = math.MaxInt32
	for _, layerData := range stats {
		if layerData.zeroes < lowestZeros {
			lowestZeros = layerData.zeroes
			lowestLayer = layerData.layer
		}
	}
	var result int = stats[lowestLayer].ones * stats[lowestLayer].twos
	fmt.Println("Layer:", lowestLayer, "1s * 2s", result)

	finalLayer := make([]int, width*height)

	for p := 0; p < width*height; p++ {
		pixelStack := make([]int, len(stats))
		for layer := 0; layer < len(stats); layer++ {
			pixelStack[layer] = rawDigits[layer*(width*height)+p]
		}
		finalLayer[p] = calcPixel(pixelStack)
	}

	for row := 0; row < height; row++ {
		for x := 0; x < width; x++ {
			if finalLayer[width*row+x] == 1 {
				fmt.Print("")
			} else {
				fmt.Print(" ")
			}
		}
		fmt.Print("\n")
	}
}

func day9() {
	rawCodes := []int64{1102,34463338,34463338,63,1007,63,34463338,63,1005,63,53,1102,3,1,1000,109,988,209,12,9,1000,209,6,209,3,203,0,1008,1000,1,63,1005,63,65,1008,1000,2,63,1005,63,904,1008,1000,0,63,1005,63,58,4,25,104,0,99,4,0,104,0,99,4,17,104,0,99,0,0,1101,0,31,1019,1101,25,0,1008,1102,35,1,1009,1102,422,1,1029,1102,1,21,1005,1102,1,734,1027,1102,29,1,1000,1101,32,0,1018,1102,28,1,1016,1101,0,38,1015,1101,0,378,1023,1101,30,0,1017,1102,1,381,1022,1101,0,37,1006,1102,1,1,1021,1101,0,24,1011,1102,1,23,1002,1101,0,0,1020,1101,0,20,1007,1101,427,0,1028,1101,26,0,1014,1101,27,0,1010,1101,0,39,1001,1101,34,0,1012,1102,1,36,1013,1101,0,33,1003,1101,804,0,1025,1101,737,0,1026,1102,1,809,1024,1102,1,22,1004,109,9,1201,-7,0,63,1008,63,20,63,1005,63,205,1001,64,1,64,1106,0,207,4,187,1002,64,2,64,109,2,21102,40,1,1,1008,1012,40,63,1005,63,233,4,213,1001,64,1,64,1106,0,233,1002,64,2,64,109,4,1208,-7,25,63,1005,63,255,4,239,1001,64,1,64,1106,0,255,1002,64,2,64,109,-24,1207,10,38,63,1005,63,271,1105,1,277,4,261,1001,64,1,64,1002,64,2,64,109,25,21107,41,40,-3,1005,1013,293,1105,1,299,4,283,1001,64,1,64,1002,64,2,64,109,5,1205,-1,311,1106,0,317,4,305,1001,64,1,64,1002,64,2,64,109,-23,1202,6,1,63,1008,63,22,63,1005,63,339,4,323,1105,1,343,1001,64,1,64,1002,64,2,64,109,1,2101,0,2,63,1008,63,37,63,1005,63,367,1001,64,1,64,1106,0,369,4,349,1002,64,2,64,109,29,2105,1,-5,1106,0,387,4,375,1001,64,1,64,1002,64,2,64,109,-26,2101,0,0,63,1008,63,23,63,1005,63,409,4,393,1106,0,413,1001,64,1,64,1002,64,2,64,109,26,2106,0,0,4,419,1106,0,431,1001,64,1,64,1002,64,2,64,109,-17,21108,42,42,6,1005,1017,453,4,437,1001,64,1,64,1106,0,453,1002,64,2,64,109,7,21101,43,0,-8,1008,1010,44,63,1005,63,477,1001,64,1,64,1105,1,479,4,459,1002,64,2,64,109,-7,1206,10,495,1001,64,1,64,1106,0,497,4,485,1002,64,2,64,109,-5,2108,36,0,63,1005,63,513,1106,0,519,4,503,1001,64,1,64,1002,64,2,64,109,3,2102,1,-5,63,1008,63,22,63,1005,63,541,4,525,1105,1,545,1001,64,1,64,1002,64,2,64,109,3,1207,-6,38,63,1005,63,567,4,551,1001,64,1,64,1105,1,567,1002,64,2,64,109,-15,2107,20,8,63,1005,63,585,4,573,1106,0,589,1001,64,1,64,1002,64,2,64,109,-1,1208,5,36,63,1005,63,609,1001,64,1,64,1106,0,611,4,595,1002,64,2,64,109,30,21101,44,0,-7,1008,1019,44,63,1005,63,633,4,617,1106,0,637,1001,64,1,64,1002,64,2,64,109,-25,1201,0,0,63,1008,63,39,63,1005,63,659,4,643,1105,1,663,1001,64,1,64,1002,64,2,64,109,27,1206,-8,677,4,669,1106,0,681,1001,64,1,64,1002,64,2,64,109,-28,2108,29,0,63,1005,63,703,4,687,1001,64,1,64,1106,0,703,1002,64,2,64,109,5,21107,45,46,7,1005,1012,725,4,709,1001,64,1,64,1106,0,725,1002,64,2,64,109,30,2106,0,-8,1105,1,743,4,731,1001,64,1,64,1002,64,2,64,109,-22,21102,46,1,4,1008,1017,44,63,1005,63,767,1001,64,1,64,1105,1,769,4,749,1002,64,2,64,109,-15,1202,10,1,63,1008,63,23,63,1005,63,793,1001,64,1,64,1106,0,795,4,775,1002,64,2,64,109,19,2105,1,7,4,801,1105,1,813,1001,64,1,64,1002,64,2,64,109,6,1205,-2,827,4,819,1106,0,831,1001,64,1,64,1002,64,2,64,109,-20,2107,22,2,63,1005,63,851,1001,64,1,64,1106,0,853,4,837,1002,64,2,64,109,20,21108,47,44,-8,1005,1015,869,1105,1,875,4,859,1001,64,1,64,1002,64,2,64,109,-22,2102,1,4,63,1008,63,23,63,1005,63,899,1001,64,1,64,1106,0,901,4,881,4,64,99,21101,0,27,1,21102,915,1,0,1106,0,922,21201,1,28703,1,204,1,99,109,3,1207,-2,3,63,1005,63,964,21201,-2,-1,1,21101,0,942,0,1106,0,922,22101,0,1,-1,21201,-2,-3,1,21101,957,0,0,1105,1,922,22201,1,-1,-2,1105,1,968,21201,-2,0,-2,109,-3,2105,1,0}
	// Test values
	//rawCodes := []int64{109,1,204,-1,1001,100,1,100,1008,100,16,101,1006,101,0,99}
	//rawCodes := []int64{1102,34915192,34915192,7,4,7,99,0}
	//rawCodes := []int64{104,1125899906842624,99}
	var codes = make([]int64, len(rawCodes))
	copy(codes, rawCodes)
	pos0 := runIntComp(codes, gatherInputFromUser, printOutputHandler)

	fmt.Println("Position 0:", pos0)
}

func gcdTwoNumbers(x int, y int) (gcd int){
	// Greatest common denominator of two numbers, which gives us slope divisors
	x = AbsInt(x)
	y = AbsInt(y)
	for ; y > 0 ; {
		var t = y
		y = x % y
		x = t
	}
	return x
}

func getAngle(x1 int, y1 int, x2 int, y2 int) float64 {
	// This returns the angle of the laser, starting with "up"
	var angleRadians = (math.Atan2(float64(y1 - y2), float64(x1 - x2)) * 180) / math.Pi
	angleRadians -= 90
	if angleRadians < 0 {
		angleRadians += 360
	}

	return angleRadians
}

func checkLineOfSight(input []string, x1 int, y1 int, x2 int, y2 int) bool {
	// This just makes sure we have line of sight from one asteroid to another without other asteroids in the middle
	if string(input[y2][x2]) != "#" { return false }
	if string(input[y1][x1]) != "#" { return false }
	if y2 == y1 && x2 == x1 { return false }
	// Make sure we have a minimal slope
	var dy = y2 - y1
	var dx = x2 - x1
	if dx != dy || dy != 0 {
		var gcd = gcdTwoNumbers(dy, dx)
		dy /= gcd
		dx /= gcd
	}
	// Now start us at the next point along the slope, and continue checking through the map
	var x = x1 + dx
	var y = y1 + dy
	for ; y >= 0 && y < len(input) && x >= 0 && x < len(input[0]); {
		if string(input[y][x]) == "#" {
			if y == y2 && x == x2 {
				return true
			}
				return false
			}
		y += dy
		x += dx
	}
	return false
}

func calcAsteroidsSeen(input []string, x int, y int) (count int) {
	// Iterate through all the _other_ asteroid points from a given asteroid point
	var asteroidsSeen = map[string]bool{}
	// Just brute force Lines to every point in the map to see what we hit
	for tx := 0; tx < len(input[0]); tx++ {
		for ty := 0; ty < len(input); ty++ {
			if tx == x && ty == y {
				continue
			}
			hit := checkLineOfSight(input, x, y, tx, ty)
			//fmt.Println("HitX and HitY:", hitX, hitY)
			if hit {
				key := string(tx) + "," + string(ty)
				if _, exists := asteroidsSeen[key]; !exists {
					asteroidsSeen[key] = true
				}
			}
		}
	}
	return len(asteroidsSeen)
}

type angleCoordinates struct {
	angle float64
	x int
	y int
}

func day10() {
	// Today's solution uses a lot of pfgithub's Javascript version, because grid ray tracing isn't my forte
	var input = []string{
		".#......#...#.....#..#......#..##..#",
		"..#.......#..........#..##.##.......",
		"##......#.#..#..#..##...#.##.###....",
		"..#........#...........#.......##...",
		".##.....#.......#........#..#.#.....",
		".#...#...#.....#.##.......#...#....#",
		"#...#..##....#....#......#..........",
		"....#......#.#.....#..#...#......#..",
		"......###.......#..........#.##.#...",
		"#......#..#.....#..#......#..#..####",
		".##...##......##..#####.......##....",
		".....#...#.........#........#....#..",
		"....##.....#...#........#.##..#....#",
		"....#........#.###.#........#...#..#",
		"....#..#.#.##....#.........#.....#.#",
		"##....###....##..#..#........#......",
		".....#.#.........#.......#....#....#",
		".###.....#....#.#......#...##.##....",
		"...##...##....##.........#...#......",
		".....#....##....#..#.#.#...##.#...#.",
		"#...#.#.#.#..##.#...#..#..#..#......",
		"......#...#...#.#.....#.#.....#.####",
		"..........#..................#.#.##.",
		"....#....#....#...#..#....#.....#...",
		".#####..####........#...............",
		"#....#.#..#..#....##......#...#.....",
		"...####....#..#......#.#...##.....#.",
		"..##....#.###.##.#.##.#.....#......#",
		"....#.####...#......###.....##......",
		".#.....#....#......#..#..#.#..#.....",
		"..#.......#...#........#.##...#.....",
		"#.....####.#..........#.#.......#...",
		"..##..#..#.....#.#.........#..#.#.##",
		".........#..........##.#.##.......##",
		"#..#.....#....#....#.#.......####..#",
		"..............#.#...........##.#.#..",
	}

	// Jacob's
	//var input = []string {
	//	".#......##.#..#.......#####...#..",
	//	"...#.....##......###....#.##.....",
	//	"..#...#....#....#............###.",
	//	".....#......#.##......#.#..###.#.",
	//	"#.#..........##.#.#...#.##.#.#.#.",
	//	"..#.##.#...#.......#..##.......##",
	//	"..#....#.....#..##.#..####.#.....",
	//	"#.............#..#.........#.#...",
	//	"........#.##..#..#..#.#.....#.#..",
	//	".........#...#..##......###.....#",
	//	"##.#.###..#..#.#.....#.........#.",
	//	".#.###.##..##......#####..#..##..",
	//	".........#.......#.#......#......",
	//	"..#...#...#...#.#....###.#.......",
	//	"#..#.#....#...#.......#..#.#.##..",
	//	"#.....##...#.###..#..#......#..##",
	//	"...........#...#......#..#....#..",
	//	"#.#.#......#....#..#.....##....##",
	//	"..###...#.#.##..#...#.....#...#.#",
	//	".......#..##.#..#.............##.",
	//	"..###........##.#................",
	//	"###.#..#...#......###.#........#.",
	//	".......#....#.#.#..#..#....#..#..",
	//	".#...#..#...#......#....#.#..#...",
	//	"#.#.........#.....#....#.#.#.....",
	//	".#....#......##.##....#........#.",
	//	"....#..#..#...#..##.#.#......#.#.",
	//	"..###.##.#.....#....#.#......#...",
	//	"#.##...#............#..#.....#..#",
	//	".#....##....##...#......#........",
	//	"...#...##...#.......#....##.#....",
	//	".#....#.#...#.#...##....#..##.#.#",
	//	".#.#....##.......#.....##.##.#.##",
	//}

	// TestInput
	//var input = []string {
	//	".#..##.###...#######",
	//	"##.############..##.",
	//	".#.######.########.#",
	//	".###.#######.####.#.",
	//	"#####.##.#.##.###.##",
	//	"..#####..#.#########",
	//	"####################",
	//	"#.####....###.#.#.##",
	//	"##.#################",
	//	"#####.##.###..####..",
	//	"..######..##.#######",
	//	"####.##.####...##..#",
	//	".#####..#.######.###",
	//	"##...#.##########...",
	//	"#.##########.#######",
	//	".####.#.###.###.#.##",
	//	"....##.##.###..#####",
	//	".#.#.###########.###",
	//	"#.#.#.#####.####.###",
	//	"###.##.####.##.#..##",
	//}

	var count, bestX, bestY int
	var bestPoint string

	for x := 0; x < len(input[0]); x++ {
		for y := 0; y < len(input); y++ {
			pointCount := calcAsteroidsSeen(input, x, y)
			if pointCount > count {
				count = pointCount
				bestX = x
				bestY = y
				bestPoint = strconv.FormatInt(int64(x), 10) + "," + strconv.FormatInt(int64(y), 10)
			}
		}
	}
	fmt.Println("Best point with count:", bestPoint, count)

	var hits = []angleCoordinates{}

	for y2 := 0; y2 < len(input); y2++ {
		for x2 := 0; x2 < len(input[0]); x2++ {
			hit := checkLineOfSight(input, bestX, bestY, x2, y2)
			if !hit {
				continue
			}
			hits = append(hits, angleCoordinates{getAngle(bestX, bestY, x2, y2), x2, y2})
		}
	}
	sort.Slice(hits, func(i, j int) bool {
		return hits[i].angle < hits[j].angle
	})

	fmt.Println(hits[199].x, hits[199].y)
}

const (
	UP int64 = 0
	DOWN int64 = 1
	LEFT int64 = 2
	RIGHT int64 = 3
)

func turnRobot(currentDirection int64, turnDirection int64) (newDirection int64) {
	if turnDirection == 0 { // Turn left
		switch currentDirection {
		case UP:
			return LEFT
		case LEFT:
			return DOWN
		case DOWN:
			return RIGHT
		case RIGHT:
			return UP
		}
	} else {
		switch currentDirection {
		case UP:
			return RIGHT
		case RIGHT:
			return DOWN
		case DOWN:
			return LEFT
		case LEFT:
			return UP
		}
	}
	return currentDirection
}

func generateRobotIOHandlers(initial int64) (input func() int64, output func(int64), getMap func() (map[gridPoint]bool, []gridPoint)){
	var hullMap = map[gridPoint]bool{}
	var firstInput = true
	var isColorInstruction bool = true
	var currentGridPoint = gridPoint{0,0}
	var lowGridPoint = gridPoint{0,0}
	var highGridPoint = gridPoint{0,0}
	var currentDirection = UP
	var directionMove = []gridPoint{
		{1, 0},
		{-1, 0},
		{0, -1},
		{0, 1},
	}

	output = func(value int64) {
		if isColorInstruction {
			hullMap[currentGridPoint] = value != 0
		} else {
			currentDirection = turnRobot(currentDirection, value)
			moveAdjusts := directionMove[currentDirection]
			currentGridPoint.x += moveAdjusts.x
			currentGridPoint.y += moveAdjusts.y

			if currentGridPoint.x < lowGridPoint.x {lowGridPoint.x = currentGridPoint.x}
			if currentGridPoint.y < lowGridPoint.y {lowGridPoint.y = currentGridPoint.y}
			if currentGridPoint.x > highGridPoint.x {highGridPoint.x = currentGridPoint.x}
			if currentGridPoint.y > highGridPoint.y {highGridPoint.y = currentGridPoint.y}
		}
		isColorInstruction = !isColorInstruction
	}

	input = func() int64 {
		if firstInput {
			firstInput = false
			return initial
		}
		if color, exists := hullMap[currentGridPoint]; exists {
			if color {
				return 1
			}
		}
		return 0
	}

	getMap = func() (map[gridPoint]bool, []gridPoint) {
		return hullMap, []gridPoint{lowGridPoint, highGridPoint}
	}
	return input, output, getMap
}

func day11() {
	var rawCodes = []int64{3,8,1005,8,326,1106,0,11,0,0,0,104,1,104,0,3,8,1002,8,-1,10,101,1,10,10,4,10,108,0,8,10,4,10,101,0,8,28,2,1104,14,10,3,8,102,-1,8,10,101,1,10,10,4,10,1008,8,1,10,4,10,101,0,8,55,3,8,102,-1,8,10,101,1,10,10,4,10,1008,8,1,10,4,10,1001,8,0,77,2,103,7,10,3,8,102,-1,8,10,101,1,10,10,4,10,108,0,8,10,4,10,102,1,8,102,1006,0,76,1,6,5,10,1,1107,3,10,3,8,1002,8,-1,10,1001,10,1,10,4,10,108,1,8,10,4,10,1001,8,0,135,1,1002,8,10,2,1101,3,10,1006,0,97,1,101,0,10,3,8,1002,8,-1,10,101,1,10,10,4,10,108,1,8,10,4,10,101,0,8,172,1006,0,77,1006,0,11,3,8,102,-1,8,10,101,1,10,10,4,10,1008,8,0,10,4,10,102,1,8,201,1006,0,95,3,8,102,-1,8,10,101,1,10,10,4,10,1008,8,1,10,4,10,1002,8,1,226,2,3,16,10,1,6,4,10,1006,0,23,1006,0,96,3,8,1002,8,-1,10,1001,10,1,10,4,10,108,0,8,10,4,10,1001,8,0,261,1,3,6,10,2,1006,3,10,1006,0,78,3,8,102,-1,8,10,101,1,10,10,4,10,1008,8,0,10,4,10,101,0,8,295,1006,0,89,1,108,12,10,2,103,11,10,101,1,9,9,1007,9,1057,10,1005,10,15,99,109,648,104,0,104,1,21102,1,838365918100,1,21102,343,1,0,1106,0,447,21102,387365315476,1,1,21102,354,1,0,1106,0,447,3,10,104,0,104,1,3,10,104,0,104,0,3,10,104,0,104,1,3,10,104,0,104,1,3,10,104,0,104,0,3,10,104,0,104,1,21101,0,179318254811,1,21102,401,1,0,1106,0,447,21102,1,97911876839,1,21101,0,412,0,1106,0,447,3,10,104,0,104,0,3,10,104,0,104,0,21101,838345577320,0,1,21101,435,0,0,1106,0,447,21102,1,838337188628,1,21101,0,446,0,1105,1,447,99,109,2,21202,-1,1,1,21101,40,0,2,21102,478,1,3,21101,0,468,0,1106,0,511,109,-2,2106,0,0,0,1,0,0,1,109,2,3,10,204,-1,1001,473,474,489,4,0,1001,473,1,473,108,4,473,10,1006,10,505,1102,1,0,473,109,-2,2106,0,0,0,109,4,2102,1,-1,510,1207,-3,0,10,1006,10,528,21101,0,0,-3,21202,-3,1,1,22101,0,-2,2,21101,1,0,3,21102,1,547,0,1106,0,552,109,-4,2106,0,0,109,5,1207,-3,1,10,1006,10,575,2207,-4,-2,10,1006,10,575,22102,1,-4,-4,1105,1,643,22102,1,-4,1,21201,-3,-1,2,21202,-2,2,3,21101,0,594,0,1105,1,552,21201,1,0,-4,21101,0,1,-1,2207,-4,-2,10,1006,10,613,21101,0,0,-1,22202,-2,-1,-2,2107,0,-3,10,1006,10,635,22102,1,-1,1,21101,635,0,0,106,0,510,21202,-2,-1,-2,22201,-4,-2,-4,109,-5,2106,0,0}

	inputFunc, outputFunc, getMap := generateRobotIOHandlers(0)
	pos0 := runIntComp(rawCodes, inputFunc, outputFunc)

	identifierMap, dimensions := getMap()
	fmt.Println("Position 0:", pos0)
	fmt.Println("Dimensions:", dimensions)
	fmt.Println("Length:", len(identifierMap))

	inputFunc, outputFunc, getMap = generateRobotIOHandlers(1)

	pos0 = runIntComp(rawCodes, inputFunc, outputFunc)

	identifierMap, dimensions = getMap()
	fmt.Println("Position 0:", pos0)
	fmt.Println("Dimensions:", dimensions)
	fmt.Println("Length:", len(identifierMap))

	fmt.Println()
	// I have X swapped.  I found this out at the end, so I'm not fixing the root issue just now.
	for x := dimensions[1].x; x >= dimensions[0].x; x-- {
		for y := dimensions[0].y; y <= dimensions[1].y; y++ {
			block := " "
			if color, exists := identifierMap[gridPoint{x, y}]; exists {
				if color {
					block = ""
				}
			}
			fmt.Print(block)
		}
		fmt.Print("\n")
	}
}

type xyzPoint struct {
	x int64
	y int64
	z int64
}

func getMoonCombinations(moonPositions []xyzPoint) [][]int {
	var combinations [][]int
	var x, y int
	for x = 0; x < len(moonPositions); x++ {
		for y = x + 1; y < len(moonPositions); y++ {
			combinations = append(combinations, []int{x, y})
		}
	}
	return combinations
}

func xyzPointsInArray(a []xyzPoint, b [][]xyzPoint) int {
	for x := 0; x < len(b); x++ {
		found := 0
		for y := 0; y < len(b[x]); y++ {
			if b[x][y] == a[y] {
				found++
			}
		}
		if found == len(a) {
			return x
		}
	}
	return -1
}

func greatestCommonDenominator(a, b int64) int64 {
	for b != 0 {
		temp := b
		b = a % b
		a = temp
	}
	return a
}

func leastCommonMultiple(a, b int64) int64 {
	// I dont do (a*b) / gcd(a,b) becuase gcd(a,b) is a divisor of both a and b, so this is more efficient
	return (a / greatestCommonDenominator(a, b)) * b
}

func day12() {
	// Completely shamefully stolen from https://github.com/JacobPuff/AoC-2019-Golang/
	var moonPositions = []xyzPoint{(xyzPoint{17, -12, 13}), (xyzPoint{2, 1, 1}), (xyzPoint{-1, -17, 7}), (xyzPoint{12, -14, 18})}
	var copiedPositions = []xyzPoint{}
	copy(copiedPositions, moonPositions)
	var prevMoonPositions [][]xyzPoint
	var prevMoonVelocities [][]xyzPoint
	var repeatIntervals = xyzPoint{0, 0, 0}
	var repeatCount = 0
	var moonVelocities = make([]xyzPoint, len(moonPositions))
	var total int64 = 0
	var steps int64 = 0
	var afterSteps int64 = 1000
	moonCombos := getMoonCombinations(moonPositions)
	for repeatCount < 3 || steps < afterSteps {
		steps++
		//Copy positions and velocities so we dont append a pointer
		copiedPositions := make([]xyzPoint, len(moonPositions))
		copiedVelocities := make([]xyzPoint, len(moonPositions))
		copy(copiedPositions, moonPositions)
		copy(copiedVelocities, moonVelocities)
		prevMoonPositions = append(prevMoonPositions, copiedPositions)
		prevMoonVelocities = append(prevMoonVelocities, copiedVelocities)
		for _, moonCombo := range moonCombos {
			//Pull out moons and velocities to change their data
			moon0 := moonPositions[moonCombo[0]]
			moon1 := moonPositions[moonCombo[1]]

			moon0Velocity := moonVelocities[moonCombo[0]]
			moon1Velocity := moonVelocities[moonCombo[1]]

			//Change velocities per axis. Apply gravity
			if moon0.x < moon1.x {
				moon0Velocity.x++
				moon1Velocity.x--
			} else if moon0.x > moon1.x {
				moon0Velocity.x--
				moon1Velocity.x++
			}

			if moon0.y < moon1.y {
				moon0Velocity.y++
				moon1Velocity.y--
			} else if moon0.y > moon1.y {
				moon0Velocity.y--
				moon1Velocity.y++
			}

			if moon0.z < moon1.z {
				moon0Velocity.z++
				moon1Velocity.z--
			} else if moon0.z > moon1.z {
				moon0Velocity.z--
				moon1Velocity.z++
			}

			//Set moons and velocities with changed data
			moonPositions[moonCombo[0]] = moon0
			moonPositions[moonCombo[1]] = moon1

			moonVelocities[moonCombo[0]] = moon0Velocity
			moonVelocities[moonCombo[1]] = moon1Velocity
		}

		for moonIndex := range moonPositions {
			//Change positions for velocities
			moon := moonPositions[moonIndex]
			moonVelocity := moonVelocities[moonIndex]
			moon.x += moonVelocity.x
			moon.y += moonVelocity.y
			moon.z += moonVelocity.z
			moonPositions[moonIndex] = moon
			moonVelocities[moonIndex] = moonVelocity
		}

		// Get intervals
		if repeatIntervals.x == 0 {
			var allMatch bool = true
			for _, velocity := range moonVelocities {
				if velocity.x != 0 {
					allMatch = false
					break
				}
			}
			if allMatch {
				repeatIntervals.x = steps
				fmt.Println("Found X")
				repeatCount++
			}
		}

		if repeatIntervals.y == 0 {
			var allMatch bool = true
			for _, velocity := range moonVelocities {
				if velocity.y != 0 {
					allMatch = false
					break
				}
			}
			if allMatch {
				repeatIntervals.y = steps
				fmt.Println("Found Y")
				repeatCount++
			}
		}

		if repeatIntervals.z == 0 {
			var allMatch bool = true
			for _, velocity := range moonVelocities {
				if velocity.z != 0 {
					allMatch = false
					break
				}
			}
			if allMatch {
				repeatIntervals.z = steps
				fmt.Println("Found Z")
				repeatCount++
			}
		}

		if steps == afterSteps {
			//Get total energy
			for moonIndex := range moonPositions {
				var totalPotential int64
				var totalKinetic int64
				totalPotential += Abs(moonPositions[moonIndex].x)
				totalPotential += Abs(moonPositions[moonIndex].y)
				totalPotential += Abs(moonPositions[moonIndex].z)
				totalKinetic += Abs(moonVelocities[moonIndex].x)
				totalKinetic += Abs(moonVelocities[moonIndex].y)
				totalKinetic += Abs(moonVelocities[moonIndex].z)
				total += totalPotential * totalKinetic
			}
			fmt.Println("total energy:", total)
		}
	}

	pastPointSteps := leastCommonMultiple(repeatIntervals.x, repeatIntervals.y)
	pastPointSteps = leastCommonMultiple(pastPointSteps, repeatIntervals.z) * 2
	fmt.Println("Steps to past point in time:", pastPointSteps)
}

func generateGameIOHandlers() (input func() int64, output func(int64), printMap func()) {
	var width, height, phase, x, y, score, currentBallX, currentPaddleX int64
	var display = map[string]string{}
	var ballChar = ""
	var blockChar = ""
	var paddleChar = ""

	var tileMap = []string {
		" ",
		"",
		blockChar,
		paddleChar,
		ballChar,
	}

	height = 19

	input = func() int64 {
		if currentBallX < currentPaddleX {
			return -1
		} else if currentBallX > currentPaddleX {
			return 1
		}
		return 0
	}

	printMap = func() {
		var blocks int64
		for row := int64(0); row < height; row++ {
			for col := int64(0); col < width; col++ {
				point := string(col) + "," + string(row)
				if display[point] == blockChar {
					blocks++
				}
				fmt.Print(display[point])
			}
			fmt.Println()
		}
		fmt.Println(score, "        ", blocks)
	}

	output = func(value int64) {
		switch phase{
		case 0:
			if width <= value {
				width = value + 1
			}
			x = value
			phase++
		case 1:
			if height <= value {
				height = value + 1
			}
			y = value
			phase++
		case 2:
			if x != -1 {
				if tileMap[value] == paddleChar {
					currentPaddleX = x
				}
				if tileMap[value] == ballChar {
					currentBallX = x
				}
				display[string(x)+","+string(y)] = tileMap[value]
			} else {
				score = value
			}
			phase = 0
			if x == width-1 && y == height-1 {
				printMap()
			}
		}
	}

	return input, output, printMap
}

func day13() {
	var game = []int64{2,380,379,385,1008,2159,116649,381,1005,381,12,99,109,2160,1101,0,0,383,1101,0,0,382,21001,382,0,1,21001,383,0,2,21102,1,37,0,1106,0,578,4,382,4,383,204,1,1001,382,1,382,1007,382,38,381,1005,381,22,1001,383,1,383,1007,383,20,381,1005,381,18,1006,385,69,99,104,-1,104,0,4,386,3,384,1007,384,0,381,1005,381,94,107,0,384,381,1005,381,108,1105,1,161,107,1,392,381,1006,381,161,1102,-1,1,384,1105,1,119,1007,392,36,381,1006,381,161,1102,1,1,384,21002,392,1,1,21101,0,18,2,21102,1,0,3,21101,0,138,0,1106,0,549,1,392,384,392,20102,1,392,1,21102,18,1,2,21102,3,1,3,21101,0,161,0,1105,1,549,1101,0,0,384,20001,388,390,1,21002,389,1,2,21101,180,0,0,1106,0,578,1206,1,213,1208,1,2,381,1006,381,205,20001,388,390,1,21002,389,1,2,21101,0,205,0,1106,0,393,1002,390,-1,390,1102,1,1,384,21001,388,0,1,20001,389,391,2,21102,228,1,0,1105,1,578,1206,1,261,1208,1,2,381,1006,381,253,20102,1,388,1,20001,389,391,2,21101,253,0,0,1105,1,393,1002,391,-1,391,1102,1,1,384,1005,384,161,20001,388,390,1,20001,389,391,2,21102,1,279,0,1106,0,578,1206,1,316,1208,1,2,381,1006,381,304,20001,388,390,1,20001,389,391,2,21102,304,1,0,1105,1,393,1002,390,-1,390,1002,391,-1,391,1102,1,1,384,1005,384,161,20101,0,388,1,20101,0,389,2,21102,0,1,3,21102,338,1,0,1106,0,549,1,388,390,388,1,389,391,389,20101,0,388,1,21001,389,0,2,21101,0,4,3,21101,0,365,0,1105,1,549,1007,389,19,381,1005,381,75,104,-1,104,0,104,0,99,0,1,0,0,0,0,0,0,280,17,15,1,1,19,109,3,21201,-2,0,1,22101,0,-1,2,21102,0,1,3,21102,414,1,0,1106,0,549,21202,-2,1,1,21202,-1,1,2,21102,429,1,0,1105,1,601,2101,0,1,435,1,386,0,386,104,-1,104,0,4,386,1001,387,-1,387,1005,387,451,99,109,-3,2105,1,0,109,8,22202,-7,-6,-3,22201,-3,-5,-3,21202,-4,64,-2,2207,-3,-2,381,1005,381,492,21202,-2,-1,-1,22201,-3,-1,-3,2207,-3,-2,381,1006,381,481,21202,-4,8,-2,2207,-3,-2,381,1005,381,518,21202,-2,-1,-1,22201,-3,-1,-3,2207,-3,-2,381,1006,381,507,2207,-3,-4,381,1005,381,540,21202,-4,-1,-1,22201,-3,-1,-3,2207,-3,-4,381,1006,381,529,21202,-3,1,-7,109,-8,2105,1,0,109,4,1202,-2,38,566,201,-3,566,566,101,639,566,566,1202,-1,1,0,204,-3,204,-2,204,-1,109,-4,2106,0,0,109,3,1202,-1,38,594,201,-2,594,594,101,639,594,594,20101,0,0,-2,109,-3,2105,1,0,109,3,22102,20,-2,1,22201,1,-1,1,21102,1,383,2,21101,430,0,3,21102,1,760,4,21101,0,630,0,1105,1,456,21201,1,1399,-2,109,-3,2106,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,2,2,2,0,2,2,2,0,0,2,2,2,0,2,0,2,2,0,2,2,2,2,2,0,2,2,2,0,0,0,0,0,1,1,0,0,2,2,2,2,2,2,2,2,0,2,2,0,0,2,2,0,0,2,2,2,2,0,0,0,0,0,2,2,2,2,0,0,2,0,1,1,0,0,2,2,2,0,2,2,2,2,2,2,2,0,2,0,2,2,0,0,0,2,2,0,2,2,0,2,2,2,2,2,2,2,2,0,1,1,0,0,0,2,0,2,2,2,0,2,2,2,2,2,2,2,2,0,2,0,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,0,1,1,0,0,2,0,0,2,2,2,0,2,2,2,2,0,2,0,2,0,2,2,2,2,2,2,2,0,0,2,2,2,2,2,0,2,2,0,1,1,0,2,2,0,2,0,2,2,0,2,2,2,2,0,2,2,0,2,2,0,2,2,2,2,2,2,0,2,2,2,0,2,0,2,0,0,1,1,0,2,2,2,2,2,2,2,2,0,2,0,2,2,2,0,0,0,2,0,2,2,2,0,2,2,2,2,2,0,0,2,2,0,2,0,1,1,0,0,2,2,0,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,2,0,2,2,2,2,2,2,0,1,1,0,2,0,2,2,2,0,2,2,2,0,0,2,2,2,2,0,0,0,2,2,2,0,0,2,0,0,2,2,2,2,0,2,0,0,0,1,1,0,2,2,2,2,2,2,0,0,0,0,2,2,2,2,2,2,0,0,0,0,0,2,2,2,2,0,2,2,2,2,2,0,2,0,0,1,1,0,2,2,2,0,2,2,0,0,2,2,2,2,0,0,2,2,2,0,0,2,2,0,2,0,2,0,2,0,2,2,0,2,2,2,0,1,1,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,2,0,0,2,2,2,0,0,2,2,2,0,2,2,2,2,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,19,28,61,4,98,57,92,26,50,7,4,93,91,74,82,82,53,50,44,66,37,43,26,12,68,84,76,40,36,22,37,44,27,92,66,68,29,34,45,60,40,21,65,41,40,64,92,11,36,81,37,39,87,7,42,10,72,35,35,51,60,76,47,1,6,51,48,46,18,82,84,11,42,76,65,98,62,71,83,51,79,76,70,46,10,67,87,78,6,63,38,23,97,69,82,84,20,97,83,4,70,96,75,38,33,32,69,80,52,80,91,95,2,30,56,52,49,64,38,32,18,97,82,93,76,1,8,37,42,80,66,38,53,33,1,31,40,54,90,20,78,13,65,4,35,28,67,37,28,56,69,50,89,63,20,55,68,59,90,18,28,25,73,25,39,26,6,65,83,5,14,4,31,9,53,25,2,9,34,10,21,43,23,39,15,29,52,36,10,71,35,18,90,86,53,58,7,10,33,81,5,50,64,17,84,85,17,37,48,43,71,10,13,83,8,88,66,95,42,54,91,62,64,53,58,56,42,67,12,29,34,14,58,37,37,49,42,8,41,44,41,17,62,59,54,67,43,42,65,12,23,76,79,93,12,35,65,87,12,74,28,56,74,25,68,91,69,98,26,67,54,18,25,63,60,28,84,93,93,93,7,84,52,50,7,18,16,57,27,87,61,30,20,81,59,33,98,27,15,83,89,44,26,31,79,3,46,29,24,64,94,58,87,1,87,63,55,68,27,4,98,5,8,30,73,74,30,4,57,78,33,55,1,50,16,87,67,59,62,85,3,2,89,54,44,95,34,8,10,78,75,6,70,53,48,60,68,60,79,4,51,81,66,58,44,45,91,69,24,41,96,6,98,45,87,46,29,83,29,90,13,22,7,83,56,89,62,54,87,32,12,1,78,19,37,66,42,13,49,16,32,90,43,28,72,67,42,18,10,55,27,21,75,95,24,91,9,70,48,5,49,70,11,79,23,24,93,30,21,34,40,56,25,62,55,26,38,74,67,23,33,35,41,83,79,64,61,87,4,29,66,82,67,97,46,78,95,73,15,9,90,19,52,67,66,91,73,97,51,4,35,52,33,86,35,16,45,1,18,23,72,67,94,3,8,67,87,19,10,79,35,24,57,60,21,48,55,37,58,81,95,15,48,70,37,69,92,87,85,6,13,44,21,12,9,14,61,69,18,65,56,50,20,23,23,4,72,30,92,50,91,83,17,94,10,83,21,70,50,65,20,39,70,7,61,34,57,38,38,39,55,48,68,56,24,66,18,41,60,25,56,50,43,65,61,95,25,30,95,10,51,31,41,64,52,5,21,37,62,75,55,10,96,28,85,12,28,4,86,46,14,26,48,26,77,15,69,16,58,68,91,32,5,66,53,69,48,54,38,13,10,9,18,67,45,97,65,74,72,7,47,93,79,77,87,68,80,8,53,86,77,33,74,78,94,92,22,9,41,34,76,25,66,55,53,1,62,23,82,23,70,58,43,34,16,6,15,55,7,5,51,23,14,11,94,91,40,21,18,28,1,77,86,27,97,6,7,31,58,20,64,41,16,65,8,11,6,51,48,44,81,5,78,18,27,89,24,55,97,70,83,48,37,97,77,32,41,80,30,25,63,76,75,85,84,61,65,13,82,69,41,28,9,46,57,60,71,55,70,13,26,90,20,21,29,59,80,60,33,73,14,19,83,12,35,52,51,70,79,36,36,40,55,31,80,43,76,59,33,82,116649}

	inputFunc, outputFunc, printMapFunc := generateGameIOHandlers()

	runIntComp(game, inputFunc, outputFunc)

	printMapFunc()
}

type reactionChem struct {
	amount int
	name   string
}

func getAmountOfChemProducedFromChemOfAmount(fromChem string, fromChemAmount int, producedChem string,
	neededForResult map[string][]reactionChem, producedAmount map[string]int) int {
	var amountNeeded = 0
	var stepAmount = 1000000
	var amountGuess = 0
	var found bool = false
	for !found {
		var excess = make(map[string]int)
		amountGuess += stepAmount
		amountNeeded = getNeededChemForChemOfAmount(fromChem, producedChem, amountGuess,
			neededForResult, producedAmount, excess)

		if amountNeeded > fromChemAmount {
			fmt.Print(amountGuess, " ")
			amountGuess -= stepAmount
			if stepAmount == 1 {
				found = true
			}
			stepAmount = int(math.Ceil(float64(stepAmount) / 2))
			fmt.Print(stepAmount, "\n")
		}

	}

	return amountGuess

}

func getNeededChemForChemOfAmount(neededChem string, resultChem string, amount int,
	neededForResult map[string][]reactionChem, producedAmount map[string]int, excess map[string]int) int {
	var gottenAmount int = 0
	var scale int = 1

	//ORE requires nothing to produce it, so return 0.
	if resultChem == "ORE" || amount == 0 {
		return 0
	}

	neededChemicals := neededForResult[resultChem]
	if len(neededChemicals) != 0 {
		if amount > producedAmount[resultChem] {
			scale = int(math.Ceil(float64(amount) / float64(producedAmount[resultChem])))

		}
		for _, chem := range neededChemicals {

			if chem.name == neededChem {
				gottenAmount += chem.amount * scale
				continue
			}

			// Golang % operator is the remainder function, and so a divide by 0 can happen
			// This is why I have this here
			if chem.name == "ORE" {
				continue
			}

			// If amountNeeded(4) - excess(5) is less than zero,
			// amountNeeded is set to 0 and excess would be  excess(5) -= amountNeeded(0).
			// So this temp is here to keep the amountNeeded value for later
			// so excess(5) -= tempAmount(4)
			tempAmount := (chem.amount * scale)
			amountNeeded := (chem.amount * scale) - excess[chem.name]
			if amountNeeded < 0 {
				amountNeeded = 0
			}

			excess[chem.name] -= tempAmount
			if excess[chem.name] < 0 {
				excess[chem.name] = 0
			}

			if (amountNeeded % producedAmount[chem.name]) != 0 {
				excess[chem.name] += producedAmount[chem.name] - (amountNeeded % producedAmount[chem.name])
			}

			gottenAmount += getNeededChemForChemOfAmount(neededChem, chem.name, amountNeeded,
				neededForResult, producedAmount, excess)
		}
		return gottenAmount
	}
	return 0
}

func day14() {
	// Completely shamefully stolen from https://github.com/JacobPuff/AoC-2019-Golang/
	file, err := os.Open("day14-input.txt")
	if err != nil {
		log.Fatal(err)
	}

	defer file.Close()

	var chemicalsNeededForResult = make(map[string][]reactionChem)
	var producedAmount = make(map[string]int)
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		reactionString := scanner.Text()
		//Get inputs and output for reaction
		reactionArray := strings.Split(reactionString, " => ")

		//Get result data
		resultArray := strings.Split(reactionArray[1], " ")
		resultAmount, _ := strconv.Atoi(resultArray[0])
		resultName := resultArray[1]
		producedAmount[resultName] = resultAmount

		//Get chemicals needed in structs
		var completeInputChemArray []reactionChem
		inputChemStringArray := strings.Split(reactionArray[0], ", ")
		for _, inputChem := range inputChemStringArray {
			if inputChem == "ORE" {
				completeInputChemArray = append(completeInputChemArray, reactionChem{0, "ORE"})
				continue
			}
			inputChemArray := strings.Split(inputChem, " ")
			inputChemAmount, _ := strconv.Atoi(inputChemArray[0])
			parsedInputChem := reactionChem{inputChemAmount, inputChemArray[1]}
			completeInputChemArray = append(completeInputChemArray, parsedInputChem)
		}

		chemicalsNeededForResult[resultName] = completeInputChemArray
	}
	var excessChemicals = make(map[string]int)
	oreNeededForOneFuel := getNeededChemForChemOfAmount("ORE", "FUEL", 1,
		chemicalsNeededForResult, producedAmount, excessChemicals)
	fuelProducedFromTrillionOre := getAmountOfChemProducedFromChemOfAmount("ORE", 1000000000000, "FUEL",
		chemicalsNeededForResult, producedAmount)
	fmt.Println("Ore needed for one fuel:", oreNeededForOneFuel)
	fmt.Println("Fuel produced from one trillion ore:", fuelProducedFromTrillionOre)
}

type droidTile struct {
	tile     string
	traveled bool
}

const (
	NORTH int64 = 1
	SOUTH int64 = 2
	WEST  int64 = 3
	EAST  int64 = 4
)

func clearConsole(OS string) {

	switch OS {
	case "linux":
		cmd := exec.Command("clear") //Linux example, its tested
		cmd.Stdout = os.Stdout
		cmd.Run()
	case "windows":
		cmd := exec.Command("cmd", "/c", "cls") //Windows example, its tested
		cmd.Stdout = os.Stdout
		cmd.Run()
	}
}

func getPointForDirection(dir int64, pos gridPoint) gridPoint {
	var tilePoint gridPoint
	switch dir {
	case NORTH:
		tilePoint = gridPoint{pos.x, pos.y - 1}
	case SOUTH:
		tilePoint = gridPoint{pos.x, pos.y + 1}
	case WEST:
		tilePoint = gridPoint{pos.x - 1, pos.y}
	case EAST:
		tilePoint = gridPoint{pos.x + 1, pos.y}
	}
	return tilePoint
}

func drawAreaAroundDroid(area map[gridPoint]droidTile, topLeft, bottomRight gridPoint) {
	for y := topLeft.y; y <= bottomRight.y; y++ {
		for x := topLeft.x; x <= bottomRight.x; x++ {
			if area[gridPoint{x, y}].tile == "" {
				fmt.Print(" ")
			} else {
				fmt.Print(area[gridPoint{x, y}].tile)
			}
		}
		fmt.Println()
	}
}

func getDroidIOHandlers(drawSetting int64) (inputGatherer, outputHandler, func() []gridPoint, func() int64) {
	var shortestPath []gridPoint
	rand.Seed(time.Now().UnixNano())
	var areaAroundDroid = make(map[gridPoint]droidTile)
	var stack []gridPoint
	var topLeft gridPoint
	var bottomRight gridPoint
	var OxygenTankPoint gridPoint

	var found bool = false
	var gotMap bool = false
	var backtracking bool = false
	var availableDirs = []int64{NORTH, SOUTH, WEST, EAST}
	var dir int64 = NORTH
	var currentPos = gridPoint{0, 0}
	areaAroundDroid[currentPos] = droidTile{"D", true}

	in := func() int64 {
		for {
			if len(availableDirs) == 0 {
				backtracking = true
				if currentPos == (gridPoint{0, 0}) {
					gotMap = true
					if drawSetting == 0 {
						drawAreaAroundDroid(areaAroundDroid, topLeft, bottomRight)
					}
					return 0
				}
				switch drawSetting {
				case 1:
					fmt.Print("OUT OF DIRS, BACKTRACKING.")
				case 2:
					if found {
						fmt.Print("OUT OF DIRS, BACKTRACKING.")
					}
				}
				if currentPos.x < stack[len(stack)-1].x {
					dir = EAST
				}
				if currentPos.x > stack[len(stack)-1].x {
					dir = WEST
				}
				if currentPos.y < stack[len(stack)-1].y {
					dir = SOUTH
				}
				if currentPos.y > stack[len(stack)-1].y {
					dir = NORTH
				}
				stack = stack[:len(stack)-1]
				return dir
			}
			backtracking = false

			dirIndex := int64(rand.Intn(len(availableDirs)) % 4)
			dir = availableDirs[dirIndex]
			tilePoint := getPointForDirection(dir, currentPos)
			tile := areaAroundDroid[tilePoint]

			if tile.traveled {
				availableDirs = append(availableDirs[:dirIndex], availableDirs[dirIndex+1:]...)
				continue
			}
			return dir
		}
	}

	out := func(output int64) {
		availableDirs = []int64{NORTH, SOUTH, WEST, EAST}

		tilePoint := getPointForDirection(dir, currentPos)
		tile := areaAroundDroid[tilePoint]
		tile.traveled = true
		switch output {
		case 0:
			tile.tile = "#"
			areaAroundDroid[tilePoint] = tile
		case 1:
			// For drawing droid
			tile.tile = "D"
			currentTile := areaAroundDroid[currentPos]
			currentTile.tile = "-"
			if currentPos == OxygenTankPoint && currentPos != (gridPoint{0, 0}) {
				currentTile.tile = "O"
			}
			areaAroundDroid[currentPos] = currentTile

			if tilePoint.x < topLeft.x {
				topLeft.x = tilePoint.x
			}
			if tilePoint.y < topLeft.y {
				topLeft.y = tilePoint.y
			}
			if tilePoint.x > bottomRight.x {
				bottomRight.x = tilePoint.x
			}
			if tilePoint.y > bottomRight.y {
				bottomRight.y = tilePoint.y
			}
			if !backtracking {
				stack = append(stack, currentPos)
			}
			currentPos = tilePoint
		case 2:
			// Copy stack now that the droid has found the oxygen system
			tile.tile = "O"
			stack = append(stack, currentPos)
			shortestPath = make([]gridPoint, len(stack))
			currentPos = tilePoint
			OxygenTankPoint = tilePoint
			copy(shortestPath, stack)
			found = true
		}
		areaAroundDroid[tilePoint] = tile

		switch drawSetting {
		case 1:
			clearConsole("windows")
			drawAreaAroundDroid(areaAroundDroid, topLeft, bottomRight)
			if found {
				fmt.Println("FOUND")
			}
		case 2:
			if found {
				clearConsole("windows")
				drawAreaAroundDroid(areaAroundDroid, topLeft, bottomRight)
				fmt.Println("FOUND")
			}
		}
	}

	getShortestPath := func() []gridPoint {
		return shortestPath
	}

	getTimeForOxygenSpread := func() int64 {
		var time int64 = 0
		var canGoToQueue []gridPoint
		var perMinuteQueue []gridPoint
		canGoToQueue = append(canGoToQueue, OxygenTankPoint)
		availableDirs = []int64{NORTH, SOUTH, WEST, EAST}

		for len(canGoToQueue) != 0 {
			perMinuteQueue = make([]gridPoint, len(canGoToQueue))
			copy(perMinuteQueue, canGoToQueue)
			canGoToQueue = []gridPoint{}
			for _, point := range perMinuteQueue {

				for _, dir := range availableDirs {
					dirPoint := getPointForDirection(dir, point)
					dirTile := areaAroundDroid[dirPoint]
					if dirTile.tile != "#" && dirTile.tile != "O" {
						dirTile.tile = "O"
						areaAroundDroid[dirPoint] = dirTile
						canGoToQueue = append(canGoToQueue, dirPoint)
					}
				}
			}

			time++
			if drawSetting > 0 && drawSetting < 4 {
				clearConsole("windows")
				drawAreaAroundDroid(areaAroundDroid, topLeft, bottomRight)
				if found {
					fmt.Println("FOUND")
				}
			}
		}
		//Oxygen tank is the first point, so subtract one to account for that.
		time -= 1

		return time
	}

	return in, out, getShortestPath, getTimeForOxygenSpread
}

func day15() {
	// Completely shamefully stolen from https://github.com/JacobPuff/AoC-2019-Golang/
	var repairBotProgram = []int64{3,1033,1008,1033,1,1032,1005,1032,31,1008,1033,2,1032,1005,1032,58,1008,1033,3,1032,1005,1032,81,1008,1033,4,1032,1005,1032,104,99,1002,1034,1,1039,1001,1036,0,1041,1001,1035,-1,1040,1008,1038,0,1043,102,-1,1043,1032,1,1037,1032,1042,1105,1,124,1001,1034,0,1039,102,1,1036,1041,1001,1035,1,1040,1008,1038,0,1043,1,1037,1038,1042,1105,1,124,1001,1034,-1,1039,1008,1036,0,1041,101,0,1035,1040,102,1,1038,1043,1001,1037,0,1042,1106,0,124,1001,1034,1,1039,1008,1036,0,1041,1001,1035,0,1040,102,1,1038,1043,1001,1037,0,1042,1006,1039,217,1006,1040,217,1008,1039,40,1032,1005,1032,217,1008,1040,40,1032,1005,1032,217,1008,1039,9,1032,1006,1032,165,1008,1040,5,1032,1006,1032,165,1101,0,2,1044,1105,1,224,2,1041,1043,1032,1006,1032,179,1102,1,1,1044,1106,0,224,1,1041,1043,1032,1006,1032,217,1,1042,1043,1032,1001,1032,-1,1032,1002,1032,39,1032,1,1032,1039,1032,101,-1,1032,1032,101,252,1032,211,1007,0,40,1044,1106,0,224,1101,0,0,1044,1106,0,224,1006,1044,247,102,1,1039,1034,101,0,1040,1035,101,0,1041,1036,1001,1043,0,1038,1001,1042,0,1037,4,1044,1106,0,0,26,29,83,66,1,36,14,44,33,12,3,15,20,56,9,35,51,55,6,20,13,71,15,23,94,38,45,15,47,30,89,39,11,55,5,9,47,29,41,36,78,12,4,65,48,66,36,94,76,30,63,41,32,1,73,1,35,65,87,46,18,90,11,44,30,73,87,8,38,46,17,78,51,34,19,53,37,26,20,24,46,64,17,6,26,41,10,62,14,88,23,94,13,55,5,45,10,39,83,99,32,34,72,30,58,33,71,47,21,38,97,38,46,41,18,39,37,8,86,55,35,4,92,19,21,53,61,6,55,69,16,85,62,26,63,17,80,33,10,53,91,2,37,94,37,93,7,97,18,55,54,36,17,62,89,12,92,32,69,4,46,47,19,89,25,12,51,91,9,1,71,35,56,39,98,48,7,49,24,95,15,45,2,1,93,82,19,7,11,70,30,64,28,27,58,4,39,30,94,72,33,43,90,98,26,32,70,1,81,25,35,47,17,31,92,15,73,13,27,72,65,30,67,2,22,89,77,30,47,12,58,26,79,22,37,74,41,3,42,30,39,67,24,18,62,98,19,59,95,25,6,67,42,35,85,51,48,7,63,17,67,53,45,13,25,43,1,54,4,65,55,20,73,32,70,1,33,39,93,88,19,35,56,21,13,53,73,31,21,44,73,31,13,69,30,42,26,51,25,90,16,49,9,93,50,28,60,24,18,61,23,11,98,19,45,77,12,61,31,3,66,56,4,77,24,59,87,31,38,65,67,7,9,23,71,9,59,35,55,83,22,12,94,17,67,87,96,63,8,29,32,34,15,55,39,60,41,74,39,81,47,51,25,26,57,28,18,60,84,20,16,66,42,14,25,16,94,2,22,74,85,19,63,32,9,19,11,91,44,34,21,1,56,12,87,8,52,18,56,7,90,5,86,81,24,98,21,9,80,59,68,10,80,53,18,75,50,9,14,43,26,29,57,86,39,41,93,3,69,55,16,84,15,22,84,30,72,19,13,15,19,80,97,79,32,68,77,82,30,19,4,71,45,67,14,95,17,54,80,88,25,13,80,41,37,96,15,28,26,33,73,32,45,79,21,52,23,98,82,21,16,13,64,32,39,93,17,33,95,61,36,12,21,3,84,4,88,22,26,59,80,27,82,2,85,79,29,33,52,17,23,95,8,64,16,56,23,42,43,18,41,11,9,84,42,62,4,67,17,98,76,99,1,16,72,72,10,79,19,76,4,54,9,99,34,33,7,97,85,19,76,93,38,6,90,37,90,2,83,61,19,43,39,2,91,17,60,21,79,2,32,94,38,32,7,64,8,14,7,68,23,28,75,24,73,50,29,63,22,89,4,51,66,2,7,33,82,13,23,84,81,23,55,68,15,27,9,97,27,79,42,86,75,56,13,95,74,5,88,25,44,99,33,14,24,29,21,78,4,15,75,32,92,74,11,56,24,57,10,28,73,8,10,90,77,30,96,8,60,3,71,20,41,9,33,89,38,74,95,4,95,35,13,18,55,10,81,9,60,17,67,7,34,48,48,15,54,79,37,66,43,22,64,28,28,4,91,5,9,92,30,64,37,98,66,15,92,2,3,25,70,25,33,61,56,25,70,58,30,41,97,18,54,10,49,45,3,1,30,57,30,46,8,55,79,39,58,46,35,19,38,80,86,4,36,75,29,62,39,71,2,41,6,66,36,99,21,61,39,72,3,48,29,43,31,59,84,71,12,52,61,82,11,56,23,51,30,60,88,65,35,48,24,58,76,49,93,51,33,72,0,0,21,21,1,10,1,0,0,0,0,0,0}
	in, out, getShortestPath, getTimeForOxygenSpread := getDroidIOHandlers(0)
	runIntComp(repairBotProgram, in, out)

	shortestPath := getShortestPath()
	timeForOxygenSpread := getTimeForOxygenSpread()
	fmt.Println("Length of shortest path:", len(shortestPath))
	fmt.Println("Time for oxygen spread:", timeForOxygenSpread)
}

func messageOfLenAtPoint(messageLen, point int, sequence []string) []string {
	var phases int = 100
	var basePattern = []int64{0, 1, 0, -1}
	var replaceNum int64 = 0
	var addedNumsForPattern int64 = 0
	for i := 0; i < phases; i++ {
		var newSequence = make([]string, len(sequence))
		if point > len(sequence)/2 {
			replaceNum = 0
			addedNumsForPattern = 0
		}
		for replaceIndex := 0; replaceIndex < len(sequence); replaceIndex++ {
			patternIndex := 0
			count := 1
			if point > len(sequence)/2 {
				num, _ := strconv.ParseInt(sequence[(len(sequence)-1)-replaceIndex], 10, 64)
				replaceNum += num
				newSequence[(len(sequence)-1)-replaceIndex] = strconv.Itoa(int(replaceNum % 10))
			} else {
				replaceNum = 0
				addedNumsForPattern = 0
				for _, numString := range sequence {
					num, _ := strconv.ParseInt(numString, 10, 64)
					if count == replaceIndex+1 {
						count = 0
						replaceNum += addedNumsForPattern * basePattern[patternIndex]
						addedNumsForPattern = 0
						patternIndex = (patternIndex + 1) % len(basePattern)
					}

					if patternIndex == 1 || patternIndex == 3 {
						addedNumsForPattern += num
					}
					count++
				}
				// Once more because the loop ends
				replaceNum += addedNumsForPattern * basePattern[patternIndex]
				newSequence[replaceIndex] = strconv.Itoa(int(Abs(replaceNum) % 10))
			}
		}
		sequence = newSequence
	}

	return sequence[point : point+messageLen]
}

func day16() {
	// Completely shamefully stolen from https://github.com/JacobPuff/AoC-2019-Golang/
	var sequenceString string = "59712692690937920492680390886862131901538154314496197364022235676243731306353384700179627460533651346711155314756853419495734284609894966089975988246871687322567664499495407183657735571812115059436153203283165299263503632551949744441033411147947509168375383038493461562836199103303184064429083384309509676574941283043596285161244885454471652448757914444304449337194545948341288172476145567753415508006250059581738670546703862905469451368454757707996318377494042589908611965335468490525108524655606907405249860972187568380476703577532080056382150009356406585677577958020969940093556279280232948278128818920216728406595068868046480073694516140765535007"
	var sequence = strings.Split(sequenceString, "")

	// Part 1
	fmt.Println("First eight digits after 100 phases:", messageOfLenAtPoint(8, 0, sequence))

	// Part 2
	fmt.Println("Repeating sequence 10,000 times")
	var expandedSequenceString string
	for i := 0; i < 10000; i++ {
		expandedSequenceString += sequenceString
	}
	var expandedSequence = strings.Split(expandedSequenceString, "")
	skipNum, _ := strconv.Atoi(sequenceString[0:7])
	fmt.Println("Running part 2")
	trueMessage := messageOfLenAtPoint(8, skipNum, expandedSequence)

	fmt.Println("First eight digits after skipping to point", skipNum, ":", trueMessage)
}

func getVacuumIOHandlers() (inputGatherer, outputHandler, func() (map[gridPoint]int64, int64, int64)) {
	var scaffoldMap = map[gridPoint]int64{}
	var inputData = []int64{  // ASCII values!
		65,44,66,44,66,44,65,44,66,44,67,44,65,44,67,44,66,44,67,10, // A,B,B,A,B,C,A,C,B,C
		76,44,52,44,76,44,54,44,76,44,56,44,76,44,54,44,54,10, // A L,4,L,6,L,8,L,6,6,
		76,44,56,44,82,44,54,44,54,44,76,44,54,44,54,10, // B L,8,R,6,6,L,6,6,
		82,44,54,44,54,44,76,44,54,44,76,44,54,44,76,44,56,10, // C R,6,6,L,6,L,6,L,8
		110,10, // y is 121, n is 110
	}
	var x, y, inputPointer int64
	var largestX, largestY int64

	var input = func() int64 {
		retVal := inputData[inputPointer]
		inputPointer++
		return retVal
	}

	var output = func(value int64) {
		if x > largestX {
			largestX = x
		}
		if y > largestY {
			largestY = y
		}

		if value == 10 {
			x = 0
			y++
		} else {
			scaffoldMap[gridPoint{x, y}] = value
			x++
		}
	}

	var getMap = func() (map[gridPoint]int64, int64, int64) {
		return scaffoldMap, largestX, largestY
	}

	return input, output, getMap
}

func day17() {
	var vacuumBotProgram = []int64{1,330,331,332,109,3470,1101,1182,0,15,1101,1481,0,24,1002,0,1,570,1006,570,36,1001,571,0,0,1001,570,-1,570,1001,24,1,24,1105,1,18,1008,571,0,571,1001,15,1,15,1008,15,1481,570,1006,570,14,21102,1,58,0,1106,0,786,1006,332,62,99,21101,0,333,1,21102,73,1,0,1105,1,579,1102,0,1,572,1101,0,0,573,3,574,101,1,573,573,1007,574,65,570,1005,570,151,107,67,574,570,1005,570,151,1001,574,-64,574,1002,574,-1,574,1001,572,1,572,1007,572,11,570,1006,570,165,101,1182,572,127,102,1,574,0,3,574,101,1,573,573,1008,574,10,570,1005,570,189,1008,574,44,570,1006,570,158,1105,1,81,21101,0,340,1,1105,1,177,21102,477,1,1,1106,0,177,21101,514,0,1,21101,176,0,0,1106,0,579,99,21102,1,184,0,1106,0,579,4,574,104,10,99,1007,573,22,570,1006,570,165,1002,572,1,1182,21101,375,0,1,21101,0,211,0,1106,0,579,21101,1182,11,1,21102,222,1,0,1105,1,979,21102,388,1,1,21101,233,0,0,1105,1,579,21101,1182,22,1,21102,1,244,0,1105,1,979,21102,401,1,1,21101,255,0,0,1105,1,579,21101,1182,33,1,21101,266,0,0,1106,0,979,21101,414,0,1,21102,1,277,0,1105,1,579,3,575,1008,575,89,570,1008,575,121,575,1,575,570,575,3,574,1008,574,10,570,1006,570,291,104,10,21102,1,1182,1,21102,1,313,0,1105,1,622,1005,575,327,1102,1,1,575,21102,327,1,0,1106,0,786,4,438,99,0,1,1,6,77,97,105,110,58,10,33,10,69,120,112,101,99,116,101,100,32,102,117,110,99,116,105,111,110,32,110,97,109,101,32,98,117,116,32,103,111,116,58,32,0,12,70,117,110,99,116,105,111,110,32,65,58,10,12,70,117,110,99,116,105,111,110,32,66,58,10,12,70,117,110,99,116,105,111,110,32,67,58,10,23,67,111,110,116,105,110,117,111,117,115,32,118,105,100,101,111,32,102,101,101,100,63,10,0,37,10,69,120,112,101,99,116,101,100,32,82,44,32,76,44,32,111,114,32,100,105,115,116,97,110,99,101,32,98,117,116,32,103,111,116,58,32,36,10,69,120,112,101,99,116,101,100,32,99,111,109,109,97,32,111,114,32,110,101,119,108,105,110,101,32,98,117,116,32,103,111,116,58,32,43,10,68,101,102,105,110,105,116,105,111,110,115,32,109,97,121,32,98,101,32,97,116,32,109,111,115,116,32,50,48,32,99,104,97,114,97,99,116,101,114,115,33,10,94,62,118,60,0,1,0,-1,-1,0,1,0,0,0,0,0,0,1,32,18,0,109,4,1202,-3,1,587,20102,1,0,-1,22101,1,-3,-3,21102,1,0,-2,2208,-2,-1,570,1005,570,617,2201,-3,-2,609,4,0,21201,-2,1,-2,1105,1,597,109,-4,2106,0,0,109,5,1202,-4,1,630,20102,1,0,-2,22101,1,-4,-4,21101,0,0,-3,2208,-3,-2,570,1005,570,781,2201,-4,-3,652,21002,0,1,-1,1208,-1,-4,570,1005,570,709,1208,-1,-5,570,1005,570,734,1207,-1,0,570,1005,570,759,1206,-1,774,1001,578,562,684,1,0,576,576,1001,578,566,692,1,0,577,577,21102,1,702,0,1106,0,786,21201,-1,-1,-1,1105,1,676,1001,578,1,578,1008,578,4,570,1006,570,724,1001,578,-4,578,21102,731,1,0,1106,0,786,1106,0,774,1001,578,-1,578,1008,578,-1,570,1006,570,749,1001,578,4,578,21101,0,756,0,1105,1,786,1106,0,774,21202,-1,-11,1,22101,1182,1,1,21101,0,774,0,1105,1,622,21201,-3,1,-3,1105,1,640,109,-5,2105,1,0,109,7,1005,575,802,21002,576,1,-6,20102,1,577,-5,1106,0,814,21101,0,0,-1,21101,0,0,-5,21101,0,0,-6,20208,-6,576,-2,208,-5,577,570,22002,570,-2,-2,21202,-5,39,-3,22201,-6,-3,-3,22101,1481,-3,-3,1202,-3,1,843,1005,0,863,21202,-2,42,-4,22101,46,-4,-4,1206,-2,924,21101,1,0,-1,1105,1,924,1205,-2,873,21102,1,35,-4,1106,0,924,1201,-3,0,878,1008,0,1,570,1006,570,916,1001,374,1,374,1201,-3,0,895,1101,0,2,0,2101,0,-3,902,1001,438,0,438,2202,-6,-5,570,1,570,374,570,1,570,438,438,1001,578,558,922,20101,0,0,-4,1006,575,959,204,-4,22101,1,-6,-6,1208,-6,39,570,1006,570,814,104,10,22101,1,-5,-5,1208,-5,51,570,1006,570,810,104,10,1206,-1,974,99,1206,-1,974,1101,0,1,575,21101,0,973,0,1105,1,786,99,109,-7,2105,1,0,109,6,21101,0,0,-4,21101,0,0,-3,203,-2,22101,1,-3,-3,21208,-2,82,-1,1205,-1,1030,21208,-2,76,-1,1205,-1,1037,21207,-2,48,-1,1205,-1,1124,22107,57,-2,-1,1205,-1,1124,21201,-2,-48,-2,1106,0,1041,21101,0,-4,-2,1106,0,1041,21102,-5,1,-2,21201,-4,1,-4,21207,-4,11,-1,1206,-1,1138,2201,-5,-4,1059,1201,-2,0,0,203,-2,22101,1,-3,-3,21207,-2,48,-1,1205,-1,1107,22107,57,-2,-1,1205,-1,1107,21201,-2,-48,-2,2201,-5,-4,1090,20102,10,0,-1,22201,-2,-1,-2,2201,-5,-4,1103,2101,0,-2,0,1105,1,1060,21208,-2,10,-1,1205,-1,1162,21208,-2,44,-1,1206,-1,1131,1105,1,989,21101,439,0,1,1106,0,1150,21102,477,1,1,1106,0,1150,21102,1,514,1,21102,1149,1,0,1106,0,579,99,21101,0,1157,0,1105,1,579,204,-2,104,10,99,21207,-3,22,-1,1206,-1,1138,2101,0,-5,1176,2101,0,-4,0,109,-6,2106,0,0,16,13,26,1,11,1,26,1,11,1,26,1,11,1,26,1,11,1,26,1,11,1,26,1,11,1,26,1,11,1,14,13,11,1,3,7,4,1,23,1,3,1,5,1,4,1,23,1,3,1,5,1,4,1,23,1,3,1,5,1,4,1,23,9,1,1,4,1,27,1,3,1,1,10,17,14,3,1,3,1,17,1,5,1,3,1,2,1,3,1,3,1,17,1,5,1,3,1,2,1,3,1,3,1,17,1,9,1,2,1,3,1,3,1,17,1,1,5,3,1,2,1,3,1,3,1,17,1,1,1,7,1,2,1,3,5,17,1,1,1,7,1,2,1,25,1,1,1,7,1,2,1,25,1,1,1,7,1,2,1,25,1,1,1,7,1,2,1,25,1,1,9,2,1,25,1,12,9,5,13,20,1,5,1,30,7,1,1,30,1,1,1,3,1,1,1,30,1,1,1,3,1,1,1,30,1,1,1,3,1,1,1,30,1,1,1,3,1,1,1,30,1,1,1,3,1,1,1,30,9,32,1,3,1,34,1,3,1,34,1,3,1,34,13,30,1,7,1,30,13,34,1,3,1,34,1,3,1,34,1,3,1,32,9,30,1,1,1,3,1,1,1,30,1,1,1,3,1,1,1,30,1,1,1,3,1,1,1,30,7,1,1,32,1,5,1,32,7,12}
	in, out, getMap := getVacuumIOHandlers()

	runIntComp(vacuumBotProgram, in, out)

	scaffoldMap, largestX, largestY := getMap()

	var sum int64

	for y := int64(0); y <= largestY; y++ {
		for x := int64(0); x <= largestX; x++ {
			var pointChar = string(scaffoldMap[gridPoint{x, y}])
			if pointChar == "#" {
				var up = string(scaffoldMap[gridPoint{x, y + 1}])
				var down = string(scaffoldMap[gridPoint{x, y - 1}])
				var right = string(scaffoldMap[gridPoint{x + 1, y}])
				var left = string(scaffoldMap[gridPoint{x - 1, y}])

				if up == "#" && down == "#" && right == "#" && left == "#" {
					pointChar = "O"
					sum += x * y
				}
			}
			fmt.Print(pointChar)
		}
		fmt.Println()
	}

	fmt.Println("Sum:", sum)

	vacuumBotProgram[0] = 2
	in, out, getMap = getVacuumIOHandlers()
	runIntComp(vacuumBotProgram, in, printOutputHandler)
	scaffoldMap, largestX, largestY = getMap()

	for y := int64(0); y <= largestY; y++ {
		for x := int64(0); x <= largestX; x++ {
			var pointChar = string(scaffoldMap[gridPoint{x, y}])
			if pointChar == "#" {
				var up = string(scaffoldMap[gridPoint{x, y + 1}])
				var down = string(scaffoldMap[gridPoint{x, y - 1}])
				var right = string(scaffoldMap[gridPoint{x + 1, y}])
				var left = string(scaffoldMap[gridPoint{x - 1, y}])

				if up == "#" && down == "#" && right == "#" && left == "#" {
					pointChar = "O"
					sum += x * y
				}
			}
			fmt.Print(pointChar)
		}
		fmt.Println()
	}

}

type Route struct {
	routeName  string
	pos        gridPoint
	length     int
	prevPoints map[string]bool
}

type keyDoorPath struct {
	startPos     gridPoint
	endPos       gridPoint
	length       int
	startName    string
	endName      string
	doorsBetween []string
	keysBetween  []string
}

func day18() {
	// Completely shamefully stolen from https://github.com/JacobPuff/AoC-2019-Golang/
	var dungeonMap = []string{
		"#################################################################################",
		"#.....#...............#.....#.A.#.......#.....#e..............#.....#...........#",
		"#.###.#########.#####.###.#.###.#.###.#.###.#.###.###########.#.#.###.#####.#####",
		"#.#.#.....#...#.#...#.#...#.....#.#.#.#.#...#..m#...#.......#.#.#.#...#.#...#...#",
		"#.#.#####.#.#.#.#.###.#.#########.#.#.###.#####.###.#.#######.###.#.###.#N###.#.#",
		"#.#.#...#...#...#...#.#.....T.......#...#.#...#.....#.#.....#.#...#.....#.#...#.#",
		"#.#.#.#.###########.#.#.###############.#.#.#.#######.#.###.#.#.#.#####.#.#.###.#",
		"#.#...#.......#.....#.#.......#.....#...#.#.#...#.........#j....#.#...#.#.#.#...#",
		"#.###########.#.#.#.#.#########.###.#.#.#.#.###.#.#########.#####.###.#.#.#.#.#.#",
		"#.#.....#...#.#.#.#.#...........#...#.#.#.#...#.#.#...#...#.#...#...#.#.#...#.#.#",
		"#.#P###.#D#.#.#.#.###############.###.#.#.###.#.#.###.#.#.###.#.###.#.#.#####.###",
		"#...#...#.#.#u..#.......#...#.....#...#.#.#...#.......#.#.....#...#...#.....#...#",
		"#####.###.#.#######.###.#.###.#######.#.#.#########.###.#########.#########.###.#",
		"#...#.#...#g......#...#.#...#.#.....#.#.#.#...#...#.#...#.......#.#.........#...#",
		"#.#.#.#.#########.###.#.###.#.###.#.#.#.#.#.#.#.#.###.#######.#.#.#.#########O#.#",
		"#.#...#..d#.....#...#.#.....#.....#...#.#...#...#.....#.....#.#.#...#.....#...#.#",
		"#.#######.#.###F###.#.#################.#.###############.#.#.#.#######.#.#.###.#",
		"#.....#...#..h#...#.#.............#.....#.#.......#.......#...#.....#...#.#.#...#",
		"#.###.#H#####.#.###G#.#######.#####.#####.###.#.#.#.###.###########.#.###.#.#####",
		"#.#.#.#.......#.#...#.....#...#...#.#...#...#.#.#.#...#.#...#.....#...#.#.#.....#",
		"#.#.#.#########.#.#########.###.#.#.###.###.#.#.#.#####.#.#.#####.#####.#.#####.#",
		"#...#.....#.....#b..#...#...#...#...#...#...#.#.#.....#...#.#y..#.......#.....#.#",
		"###.#####.#.#######.###B#.#.#.#######.#.#.#####.#####.#.###.###.#####.#.#.#####.#",
		"#...#...I.#f......#.....#.#.#.#...#...#.#...#...#...#.#.#.....#.....#.#...#.....#",
		"#####.###########.#######.###.#.###.#.#####.#.###.###.###.#########.#######.#####",
		"#o....#k........#.#.#.......#.#.#...#...#.#.#.#.....#.#...#.......#.......K.#...#",
		"#.#####.###.#####.#.#.#####.#.#.#.#####.#.#.#.###.#.#.#.###.###.###############.#",
		"#.#.......#...#.C.#.....#...#.#...#...#.#...#...#.#.#.#...#...#.....#...........#",
		"#.#.#########.#.#########.###.###.#.###.#.#####.#.#.#.###.###.#####.#.#.#######.#",
		"#...#l........#...#.....#...#...#...#...#.......#.#...#...#...#...#...#.X.#...#.#",
		"#.###.#.#########.#V###.###.###.#####.###########.#####.###.###.#########.#.#.#.#",
		"#...#.#.#.....#...#.#.#.#...#.#.....#...#.......#...#...#...#...........#.#.#.#.#",
		"#####.#.#.###.#.###.#.#.#.#.#.#####.###.#.#####.###.#.#.#.###.#######.###.#.#.#W#",
		"#.....#.#.#r#.#.#...#.#.#.#.#.#...#...#.#.#...#...#.#.#.#...#.......#...#.#.#.#.#",
		"#.#######.#.#.#.###.#.#.#.#.#.#.#.###.#.#.###.###.#.#.#.###.###########.#.#.#.#.#",
		"#.........#.#.#.#s..#...#.#.Q.#.#.#...#.#...#...#...#.#.............#...#.#.#...#",
		"#.#########.#.#.#.###.###.#.###.#.#.###.###.#.#.#####.#######.#####.#.###.#.#####",
		"#...#...#...#.#...#...#...#.#...#...#...#.#.#.#.....#...#...#.#...#...#...#...#.#",
		"###.#Y#.###.#.#####.###.#####.#########.#.#.###.###.#####.#.###.#.#####.#####.#.#",
		"#.....#.....#.......#...........................#.........#....q#.......#.......#",
		"#######################################.@.#######################################",
		"#...#.#.................#..z..............#.......#.............#...............#",
		"#.#.#.#.#.#############.#.#.###########.#.#.#.#####.#####.#####.#.###.#########.#",
		"#.#...#.#.#...#.#.....#.#.#.#.....#...#.#...#.#...Z.....#.#.....#.#.#.#.......#.#",
		"#.#####.#.#.#.#.#.#.#.#.###.#.#####.#.#.#.###.#.#########.#######.#.#.#####.###.#",
		"#.#...#.#...#.#...#.#x#.#...#.#.....#.#.#...#.....#.....#.#...#.....#.#...#.....#",
		"#.#.#.#.#####.#####.###.#.###.#.#####.#.###.#######.###.#.#.#.#.#####.#.#.#####.#",
		"#w..#...#...#.....#.#.....#...#.#.....#.#.#...#.....#.#...#.#...#..v#.#.#.....#.#",
		"#.#######.#.#####.#.#.#####.###.#.#####.#.###.#.#####.#.###.#####.#.#.#.#####.###",
		"#.#.......#.#.#...#.#.#...#.#...#.#...#.#...#.#.#.......#...#...#.#.#.#.#...#...#",
		"#.###.#.###.#.#.###.#.#.#.#.#.###.#.#.#.#.###.#.###.#####.###.#.#.#.#.#.###.###.#",
		"#...#.#...#...#.#.#...#.#.#...#.#.#.#...#...#.#...#.#...#.#...#.R.#.#.........#.#",
		"###.#####.###.#.#.#.###.#.###.#.#.#.#####.#.#.###.#.#.#.#.#.#######.#.#########.#",
		"#.#...#...#.#.#.#.....#.#...#...#.......#.#.#...#.#...#.#.#.#...#...#.#.........#",
		"#.###.#.###.#.#.#######.###.#.#########.#.#.###.#.#######.#.#.###.###.#.#######.#",
		"#...#...#...#.#.........#...#.#...#.....#.#...#.#.........#.#.#...#...#.#.......#",
		"#.#######.#.#.###########.#####.#.#####.###.###.###########.#.#.#######.#########",
		"#.........#.#.#.........#.......#.#...#.#...#...#...........#.#.#.....#.........#",
		"#.###.#######.#.###.#####.#####.#.#.#.###.#.#.###.###########.#.#.###S#########.#",
		"#...#.......#...#...#...#.#...#.#...#...#.#.#...#.....L.#.....#...#...#...#...#.#",
		"#.#########.#####.###.#.###.#.###.#####.#.#####.#######.#.#########.###.#.#.#.#.#",
		"#.#.......#.#...#.#.#.#.#...#...#...#...#...........#...#...#.#....c#...#...#.#.#",
		"###.#####.#.#.#.#.#.###.#.#####.#####.###.###########.#####.#.#.#####.#######.#.#",
		"#...#.......#.#...#...#...#...#...#...#.#...#.........#.....#...#.......#.......#",
		"#.###.#######.#####.#######.#.###.#.###.###.#.###########.#.#########.#.#######.#",
		"#.#.#.#...#...#.............#...#...#...#...#.............#.........#.#.#.....#.#",
		"#.#.#.#.#.#.###########.#####.#.#####.###.#########################.###.#.###.#.#",
		"#.#...#.#.#.....#.....#...#...#.#.#.....#.....#...#.......#.......#...#...#...#.#",
		"#.#####.#.#####.#.###.#####.###.#.#.###.#####.#.###.###.###.#####.###.#####.#####",
		"#.......#...#.#...#.#.#.....#.#.#...#...#...#.#.#.....#.........#...#.....#.....#",
		"#.#######.#.#.#####E#.#.#####.#.#.###.#.#.#.#.#.#.#############.#.#.#####.###.#.#",
		"#...#.....#...#...#...#.#.....#.#...#.#.#.#...#.....#..a#.....#.#.#...#.#...#.#.#",
		"#####.#######.#.###.###.#.###.#.#.###.#.#.###########.#.#.###.###.###.#.###.###.#",
		"#...#.#.#...#.#.#...#...#.#...#.#.#...#.#.....#.....#.#.#.#.#...#...#...#.#...#.#",
		"#.#.#.#.#.#.#.#.#.###.#.#.#.#.#.###.###.#####.#.###.#.#.#.#.###.###.###.#.###.#.#",
		"#.#.#.#.#.#.....#.#...#.#.#.#.#.....#.#.#.....#.#...#.#...#...#...#.#.#.#...#..i#",
		"#.#.#.#.#.#######.#####.###.#########.#.#.#####U#.###.#######.###.#.#.#.#.#.#####",
		"#.#n..#.......#...#...#...#.#...#.......#.......#t#...#.........#.#.#.#...#.#...#",
		"#.#############.###.#.###.#.#.#.#.###############.#.###.#.#######.#.#.#####.#.#.#",
		"#...............J...#.....#...#.........#...........#...#.........M.#..p......#.#",
		"#################################################################################",
	}


	var mazeMap = make(map[gridPoint]droidTile)
	var doors = make(map[string]bool)
	var keys = make(map[string]bool)
	var x, y int64
	var currentPos gridPoint

	for _, line := range dungeonMap {
		for index := range line {
			if line[index] == '@' {
				// mazeMap[Point{x - 1, y}] = droidTile{"#", false}
				// mazeMap[Point{x + 1, y}] = droidTile{"#", false}
				currentPos = gridPoint{x, y}
			}
			if line[index] != '#' && line[index] != '@' && line[index] != '.' {
				stringChar := string(line[index])
				if stringChar == strings.ToUpper(stringChar) {
					doors[stringChar] = true
				}
				if stringChar == strings.ToLower(stringChar) {
					keys[stringChar] = true
				}
			}

			if mazeMap[gridPoint{x, y}].tile == "" {
				mazeMap[gridPoint{x, y}] = droidTile{string(line[index]), false}
			}
			x++
		}
		x = 0
		y++
	}

	var listOfRoutes []Route
	var startRoute Route
	var shortestRouteSteps = math.MaxInt64
	// Set start route data
	startRoute.pos = currentPos
	startRoute.length = 0
	startRoute.routeName = "@"
	startRoute.prevPoints = make(map[string]bool)
	startRoute.prevPoints["@"] = true
	// Make a map to memoize things
	prevPathsCalculated := make(map[string]keyDoorPath)

	listOfRoutes = getRoutesFromStartRoute(startRoute, prevPathsCalculated, mazeMap, doors, keys, listOfRoutes)

	for _, route := range listOfRoutes {
		if route.length < shortestRouteSteps {
			shortestRouteSteps = route.length
		}
	}
	fmt.Println("Shortest path for part 1:", shortestRouteSteps)
	fmt.Println("Key len:", len(keys))
}

func canReachKey(route Route, path keyDoorPath) bool {
	var canReachKey bool = true
	for _, door := range path.doorsBetween {
		if !route.prevPoints[strings.ToLower(door)] {
			canReachKey = false
		}
	}
	return canReachKey
}

func getRoutesFromStartRoute(fromRoute Route, prevPathsCalculated map[string]keyDoorPath, mazeMap map[gridPoint]droidTile, doors map[string]bool, keys map[string]bool, listOfRoutes []Route) []Route {
	// Get all keys that the route doesnt have,
	// check if we've done calculation to that key from the route position before
	//
	// if we have, and we have all the keys for the doors,
	//    add key and length to route
	// if we haven't
	//    search for that key in a breadth first search,
	//    cache result, and add it to the route

	var route Route = Route{"", gridPoint{0, 0}, 0, make(map[string]bool)}

	for key := range keys {
		//Make new route instead of reference
		route.pos = fromRoute.pos
		route.length = fromRoute.length
		route.routeName = fromRoute.routeName
		// Copy prevPoints so its not a reference
		for key, val := range fromRoute.prevPoints {
			route.prevPoints[key] = val
		}
		if !route.prevPoints[key] {

			cacheString := fmt.Sprintf("({x: %d, y: %d}, key: %s)", route.pos.x, route.pos.y, key)
			// I used length to see if a value existed because it has a default of 0,
			// and its easy to understand that there shouldnt be a length of 0.
			var pathToKey keyDoorPath
			if prevPathsCalculated[cacheString].length != 0 {
				pathToKey = prevPathsCalculated[cacheString]
			} else {
				pathToKey = getDistanceAndDoorsBetweenPointAndKey(route.pos, key, mazeMap, doors, keys)
				prevPathsCalculated[cacheString] = pathToKey
			}
			// fmt.Println("KEY NUM:", keyNum, "KEY:", key)
			// keyNum++

			if canReachKey(route, pathToKey) {
				route.routeName += key
				for _, keyName := range pathToKey.keysBetween {
					route.prevPoints[keyName] = true
				}
				// route.prevPoints[key] = true
				route.length += pathToKey.length
				route.pos = pathToKey.endPos
				newListOfRoutes := getRoutesFromStartRoute(route, prevPathsCalculated, mazeMap, doors, keys, listOfRoutes)
				listOfRoutes = append(listOfRoutes, newListOfRoutes...)
			}

		}
	}

	var hasAllKeys = true
	for key := range keys {
		if route.prevPoints[key] == false {
			hasAllKeys = false
		}
	}
	if hasAllKeys {
		fmt.Println("finished route", fromRoute.routeName, len(route.prevPoints), route.length)
		listOfRoutes = append(listOfRoutes, fromRoute)
	}
	return listOfRoutes
}

func getDistanceAndDoorsBetweenPointAndKey(startPoint gridPoint, key string, mazeMap map[gridPoint]droidTile, doors map[string]bool, keys map[string]bool) keyDoorPath {
	availableDirs := []int64{NORTH, SOUTH, WEST, EAST}
	var canGoToQueue []gridPoint
	// var localDist int = 0
	canGoToQueue = append(canGoToQueue, startPoint)
	var mazeCopy = make(map[gridPoint]droidTile)
	// Copy mazeMap
	for key, val := range mazeMap {
		mazeCopy[key] = val
	}
	// Use point and return parent of that point
	var breadthFirstSearchTree = make(map[gridPoint]gridPoint)
	//Set start point to traveled so its parent isnt overwritten
	mazeCopy[startPoint] = droidTile{mazeCopy[startPoint].tile, true}
	breadthFirstSearchTree[startPoint] = gridPoint{-1, -1}

	var keyDoorPathToReturn keyDoorPath
	keyDoorPathToReturn.startPos = startPoint
	keyDoorPathToReturn.startName = mazeCopy[startPoint].tile
	keyDoorPathToReturn.endName = key

	for len(canGoToQueue) != 0 {
		var currentQueue = make([]gridPoint, len(canGoToQueue))
		copy(currentQueue, canGoToQueue)
		canGoToQueue = []gridPoint{}
		for _, point := range currentQueue {
			for _, dir := range availableDirs {
				dirPoint := getPointForDirection(dir, point)
				dirTile := mazeCopy[dirPoint]
				currentParent := point

				if dirTile.tile == key {
					//fmt.Println("found key", dirTile.tile)
					keyDoorPathToReturn.endPos = dirPoint
					for currentParent != (gridPoint{-1, -1}) {
						parentTile := mazeCopy[currentParent]
						if doors[mazeCopy[currentParent].tile] {
							keyDoorPathToReturn.doorsBetween = append(keyDoorPathToReturn.doorsBetween, parentTile.tile)
						}
						// Add all keys along the way
						if keys[mazeCopy[currentParent].tile] {
							keyDoorPathToReturn.keysBetween = append(keyDoorPathToReturn.keysBetween, parentTile.tile)
						}
						keyDoorPathToReturn.length++
						currentParent = breadthFirstSearchTree[currentParent]
					}
					return keyDoorPathToReturn
				}

				if dirTile.tile != "#" && dirTile.tile != "" && !dirTile.traveled {
					breadthFirstSearchTree[dirPoint] = currentParent
					dirTile.traveled = true
					mazeCopy[dirPoint] = dirTile
					canGoToQueue = append(canGoToQueue, dirPoint)
				}
			}
		}
	}
	//It shouldn't get to this point if a key exists
	keyDoorPathToReturn.endName = "ERROR"
	return keyDoorPathToReturn
}

func tractorBeamDroneIOHandlers(x, y int64) (inputGatherer, outputHandler, func() bool) {
	var sentX bool = false
	var pulled = false
	in := func() int64 {
		if !sentX {
			sentX = true
			return x
		}
		return y
	}
	out := func(output int64) {
		if output == 1 {
			pulled = true
		}
	}

	getPulled := func() bool {
		return pulled
	}
	return in, out, getPulled
}

func day19() {
	// Completely shamefully stolen from https://github.com/JacobPuff/AoC-2019-Golang/
	var tractorBeamDroneProgram = []int64{109,424,203,1,21102,11,1,0,1105,1,282,21102,1,18,0,1106,0,259,2101,0,1,221,203,1,21102,1,31,0,1106,0,282,21102,38,1,0,1105,1,259,20101,0,23,2,22101,0,1,3,21101,1,0,1,21101,57,0,0,1105,1,303,2101,0,1,222,21001,221,0,3,21002,221,1,2,21101,0,259,1,21102,80,1,0,1106,0,225,21102,89,1,2,21102,91,1,0,1105,1,303,2101,0,1,223,20101,0,222,4,21101,0,259,3,21102,1,225,2,21102,225,1,1,21102,118,1,0,1106,0,225,20101,0,222,3,21101,136,0,2,21101,133,0,0,1106,0,303,21202,1,-1,1,22001,223,1,1,21101,148,0,0,1105,1,259,1202,1,1,223,20102,1,221,4,21001,222,0,3,21102,18,1,2,1001,132,-2,224,1002,224,2,224,1001,224,3,224,1002,132,-1,132,1,224,132,224,21001,224,1,1,21102,195,1,0,106,0,108,20207,1,223,2,20102,1,23,1,21101,-1,0,3,21101,214,0,0,1105,1,303,22101,1,1,1,204,1,99,0,0,0,0,109,5,1202,-4,1,249,21201,-3,0,1,22102,1,-2,2,21202,-1,1,3,21102,1,250,0,1105,1,225,21201,1,0,-4,109,-5,2105,1,0,109,3,22107,0,-2,-1,21202,-1,2,-1,21201,-1,-1,-1,22202,-1,-2,-2,109,-3,2105,1,0,109,3,21207,-2,0,-1,1206,-1,294,104,0,99,22102,1,-2,-2,109,-3,2105,1,0,109,5,22207,-3,-4,-1,1206,-1,346,22201,-4,-3,-4,21202,-3,-1,-1,22201,-4,-1,2,21202,2,-1,-1,22201,-4,-1,1,21201,-2,0,3,21102,343,1,0,1106,0,303,1105,1,415,22207,-2,-3,-1,1206,-1,387,22201,-3,-2,-3,21202,-2,-1,-1,22201,-3,-1,3,21202,3,-1,-1,22201,-3,-1,2,21202,-4,1,1,21102,384,1,0,1105,1,303,1106,0,415,21202,-4,-1,-4,22201,-4,-3,-4,22202,-3,-2,-2,22202,-2,-4,-4,22202,-3,-2,-3,21202,-4,-1,-2,22201,-3,-2,1,21202,1,1,-4,109,-5,2106,0,0}
	pointsAffected := 0
	var x, y int64
	var sizeX int64 = 100
	var sizeY int64 = 100
	var width int64 = 50
	var height int64 = 50
	var wantedXCoord int64
	var wantedYCoord int64
	for y = 0; y < height; y++ {
		for x = 0; x < width; x++ {
			in, out, getPulled := tractorBeamDroneIOHandlers(x, y)
			runIntComp(tractorBeamDroneProgram, in, out)
			isPulled := getPulled()
			if isPulled {
				fmt.Print("#")
				pointsAffected++
			} else {
				fmt.Print(" ")
			}
		}
		fmt.Println()
	}
	fmt.Println("Points affected in 50x50 square:", pointsAffected)
	var gottenXYClosestCoords bool = false
	for !gottenXYClosestCoords {

		//Subtract 1 because the coordinates start at 0
		in, out, getPulled := tractorBeamDroneIOHandlers(x, y+sizeY-1)
		runIntComp(tractorBeamDroneProgram, in, out)
		isPulledBottomLeft := getPulled()

		in, out, getPulled = tractorBeamDroneIOHandlers(x+sizeX-1, y)
		runIntComp(tractorBeamDroneProgram, in, out)
		isPulledTopRight := getPulled()

		if isPulledBottomLeft && isPulledTopRight {
			wantedXCoord = x
			wantedYCoord = y
			gottenXYClosestCoords = true
		}

		if isPulledBottomLeft {
			x -= sizeX + 1
			y++
		} else {
			x++
		}
	}
	fmt.Println("Wanted coords to fit size of 100x100:", (wantedXCoord*10000)+wantedYCoord)
}

type teleporter struct {
	pointA gridPoint
	pointB gridPoint
	name   string
}

func day20() {
	// Completely shamefully stolen from https://github.com/JacobPuff/AoC-2019-Golang/
	file, err := os.Open("day20-input.txt")
	if err != nil {
		log.Fatal(err)
	}

	defer file.Close()

	var mazeMap = make(map[gridPoint]string)
	var teleNameMap = make(map[gridPoint]string)
	var teleMap = make(map[string]teleporter)
	scanner := bufio.NewScanner(file)

	var x, y, width, height int64
	for scanner.Scan() {
		line := scanner.Text()
		for _, char := range line {
			if char != ' ' && char != '#' && char != '.' {
				northPoint := mazeMap[gridPoint{x, y - 1}]
				westPoint := mazeMap[gridPoint{x - 1, y}]
				var telePoint gridPoint
				var teleName string
				if northPoint != "" && northPoint != " " && northPoint != "#" && northPoint != "." {
					//Look up two, to check for a period.
					if mazeMap[gridPoint{x, y - 2}] == "." {
						telePoint = gridPoint{x, y - 2}
					} else {
						telePoint = gridPoint{x, y + 1}
					}
					teleName = northPoint + string(char)
				}

				if westPoint != "" && westPoint != " " && westPoint != "#" && westPoint != "." {
					//Look back two, to check for a period.
					if mazeMap[gridPoint{x - 2, y}] == "." {
						telePoint = gridPoint{x - 2, y}
					} else {
						telePoint = gridPoint{x + 1, y}
					}
					teleName = westPoint + string(char)
				}

				//Set the teleNameMap and teleMap so I can get the telporters later
				if telePoint != (gridPoint{0, 0}) {
					teleNameMap[telePoint] = teleName
					tele := teleMap[teleName]
					if tele.pointA == (gridPoint{0, 0}) {
						tele.pointA = telePoint
					} else {
						tele.pointB = telePoint
					}
					teleMap[teleName] = tele
				}
			}

			mazeMap[gridPoint{x, y}] = string(char)
			width = x
			height = y
			x++
		}
		x = 0
		y++
	}

	fmt.Println("Done parsing maze...")

	var shortestPathWithoutLevels = []gridPoint{}
	availableDirs := []int64{NORTH, SOUTH, WEST, EAST}

	// AA and ZZ are treated like teleporters,
	// so I can loop them up that way.
	// They only have a pointA.
	var startPos = teleMap["AA"].pointA

	//Take point, return parent
	var breadthFirstMap = make(map[gridPoint]gridPoint)
	breadthFirstMap[startPos] = gridPoint{-1, -1}

	//Make it so startPos is traveled so it doesnt try to move over it and overwrite the parent
	var traveledMap = make(map[gridPoint]bool)
	traveledMap[startPos] = true

	var canGotoQueue = []gridPoint{}
	canGotoQueue = append(canGotoQueue, startPos)

	// This is the part 1 breadth first search.
	// I was going to reduce the amount of code,
	// and try and do both parts at the same time,
	// but I wanted to make it easy to read and understand.
	for len(canGotoQueue) != 0 {
		var localQueue = make([]gridPoint, len(canGotoQueue))
		copy(localQueue, canGotoQueue)
		canGotoQueue = []gridPoint{}
		for _, point := range localQueue {
			for _, dir := range availableDirs {
				dirPoint := getPointForDirection(dir, point)
				dirTile := mazeMap[dirPoint]

				if teleNameMap[dirPoint] != "" && !traveledMap[dirPoint] {
					breadthFirstMap[dirPoint] = point
					teleName := teleNameMap[dirPoint]
					if teleName == "ZZ" {
						fmt.Println("Found end of maze without levels...")
						currentParent := breadthFirstMap[dirPoint]
						for currentParent != (gridPoint{-1, -1}) {
							shortestPathWithoutLevels = append(shortestPathWithoutLevels, currentParent)
							currentParent = breadthFirstMap[currentParent]
						}
					} else {
						// fmt.Println("Using teleporter: ", teleName)
						tele := teleMap[teleName]
						if dirPoint != tele.pointA {
							breadthFirstMap[tele.pointA] = dirPoint
							traveledMap[tele.pointA] = true
							canGotoQueue = append(canGotoQueue, tele.pointA)
						} else {
							breadthFirstMap[tele.pointB] = dirPoint
							traveledMap[tele.pointB] = true
							canGotoQueue = append(canGotoQueue, tele.pointB)
						}
						traveledMap[dirPoint] = true
						mazeMap[dirPoint] = dirTile
					}
				}

				if dirTile == "." && !traveledMap[dirPoint] {
					traveledMap[dirPoint] = true
					breadthFirstMap[dirPoint] = point
					canGotoQueue = append(canGotoQueue, dirPoint)
				}
			}
		}
	}

	var shortestPathWithLevels = []xyzPoint{}
	var leftAndTopEdgeOffset int64 = 2
	var rightEdgeOffset int64 = width - 2
	var bottomEdgeOffset int64 = height - 2

	var xyzStartPos = xyzPoint{teleMap["AA"].pointA.x, teleMap["AA"].pointA.y, 0}

	//Take point, return parent
	var xyzBreadthFirstMap = make(map[xyzPoint]xyzPoint)
	xyzBreadthFirstMap[xyzStartPos] = xyzPoint{-1, -1, 0}

	//Make it so startPos is traveled so it doesnt try to move over it and overwrite the parent
	var xyzTraveledMap = make(map[xyzPoint]bool)
	xyzTraveledMap[xyzStartPos] = true

	var xyzCanGotoQueue = []xyzPoint{}
	xyzCanGotoQueue = append(xyzCanGotoQueue, xyzStartPos)

	for len(xyzCanGotoQueue) != 0 && len(shortestPathWithLevels) == 0 {
		var localQueue = make([]xyzPoint, len(xyzCanGotoQueue))
		copy(localQueue, xyzCanGotoQueue)
		xyzCanGotoQueue = []xyzPoint{}
		for _, point := range localQueue {
			for _, dir := range availableDirs {
				dirXYPoint := getPointForDirection(dir, gridPoint{point.x, point.y})
				dirPoint := xyzPoint{dirXYPoint.x, dirXYPoint.y, point.z}
				dirTile := mazeMap[dirXYPoint]

				if teleNameMap[dirXYPoint] != "" && dirTile == "." && !xyzTraveledMap[dirPoint] {
					xyzBreadthFirstMap[dirPoint] = point
					teleName := teleNameMap[dirXYPoint]
					if teleName == "ZZ" {
						// fmt.Println("Found zz at level:", dirPoint.z)
						if point.z == 0 {
							fmt.Println("Found end of maze with levels")
							currentParent := xyzBreadthFirstMap[dirPoint]
							for currentParent != (xyzPoint{-1, -1, 0}) {

								shortestPathWithLevels = append(shortestPathWithLevels, currentParent)

								currentParent = xyzBreadthFirstMap[currentParent]
							}
						}
					} else if teleName != "AA" {
						tele := teleMap[teleName]
						var teleXYZPoint xyzPoint
						var level = point.z
						if dirXYPoint == tele.pointB {
							// Because pointA is not equal, we are at pointB.
							// So if pointA is on the outer edge,
							// then we are going one level deeper at pointB on the inner edge,
							// so add one to level.
							if tele.pointA.x == leftAndTopEdgeOffset || tele.pointA.y == leftAndTopEdgeOffset ||
								tele.pointA.x == rightEdgeOffset || tele.pointA.y == bottomEdgeOffset {
								level++
							} else {
								level--
							}

							if level >= 0 && level < int64(len(teleNameMap)) {
								teleXYZPoint = xyzPoint{tele.pointA.x, tele.pointA.y, level}
							}
						} else {
							if tele.pointB.x == leftAndTopEdgeOffset || tele.pointB.y == leftAndTopEdgeOffset ||
								tele.pointB.x == rightEdgeOffset || tele.pointB.y == bottomEdgeOffset {
								level++
							} else {
								level--
							}

							if level >= 0 && level < int64(len(teleNameMap)) {
								teleXYZPoint = xyzPoint{tele.pointB.x, tele.pointB.y, level}
							}
						}
						//Dont check z axis because level can be 0
						if teleXYZPoint.x != 0 && teleXYZPoint.y != 0 {
							// fmt.Println("Using teleporter: ", teleName, "from level:", point.z, "to go to level:", level)
							xyzTraveledMap[dirPoint] = true
							xyzBreadthFirstMap[teleXYZPoint] = dirPoint
							xyzTraveledMap[teleXYZPoint] = true
							xyzCanGotoQueue = append(xyzCanGotoQueue, teleXYZPoint)
						}
					}
				}

				if dirTile == "." && !xyzTraveledMap[dirPoint] {
					xyzTraveledMap[dirPoint] = true
					xyzBreadthFirstMap[dirPoint] = point
					xyzCanGotoQueue = append(xyzCanGotoQueue, dirPoint)
				}
			}
		}
	}

	fmt.Println("Shortest path steps without levels:", len(shortestPathWithoutLevels))
	fmt.Println("Shortest path steps with levels:", len(shortestPathWithLevels))

}

const (
	A     int64 = 65
	B     int64 = 66
	C     int64 = 67
	D     int64 = 68
	E     int64 = 69
	F     int64 = 70
	G     int64 = 71
	H     int64 = 72
	I     int64 = 73
	J     int64 = 74
	K     int64 = 75
	L     int64 = 76
	N     int64 = 78
	O     int64 = 79
	R     int64 = 82
	T     int64 = 84
	U     int64 = 85
	W     int64 = 87
	SPACE int64 = 32
	NEWLINE  int64 = 10
)

func springDroidIOHandlers(shouldRun bool) (inputGatherer, outputHandler) {
	var currentChar = 0
	var droidProgram []int64

	if !shouldRun {
		// Check if spaces A, B, and C, exist.
		// Only if they all exist T will be set to true.
		// If T is false, one of those three is gone.
		// Wait until we can land on space D to jump.
		droidProgram = []int64{
			O, R, SPACE, A, SPACE, T, NEWLINE,
			A, N, D, SPACE, B, SPACE, T, NEWLINE,
			A, N, D, SPACE, C, SPACE, T, NEWLINE,
			N, O, T, SPACE, T, SPACE, J, NEWLINE,
			A, N, D, SPACE, D, SPACE, J, NEWLINE,
			W, A, L, K, NEWLINE}
	} else {
		droidProgram = []int64{
			// E lines up jumps that are off a little bit,
			// and H prevents E from killing the bot
			// AND D J could be moved above the E H lines,
			// because the droid has memory from its last state,
			// but this is easier to read.
			O, R, SPACE, A, SPACE, T, NEWLINE,
			A, N, D, SPACE, B, SPACE, T, NEWLINE,
			A, N, D, SPACE, C, SPACE, T, NEWLINE,
			N, O, T, SPACE, T, SPACE, J, NEWLINE,

			O, R, SPACE, E, SPACE, T, NEWLINE,
			O, R, SPACE, H, SPACE, T, NEWLINE,
			A, N, D, SPACE, T, SPACE, J, NEWLINE,
			A, N, D, SPACE, D, SPACE, J, NEWLINE,
			R, U, N, NEWLINE}

	}

	in := func() int64 {
		toReturn := droidProgram[currentChar]
		fmt.Print(string(toReturn))
		currentChar++
		return toReturn
	}
	out := func(output int64) {
		if output > 128 {
			fmt.Println(output)
		} else {
			fmt.Print(string(output))
		}

	}

	return in, out
}

func day21() {
	// Completely shamefully stolen from https://github.com/JacobPuff/AoC-2019-Golang/
	var springDroidProgram = []int64{109,2050,21101,0,966,1,21102,13,1,0,1106,0,1378,21102,1,20,0,1106,0,1337,21101,27,0,0,1105,1,1279,1208,1,65,748,1005,748,73,1208,1,79,748,1005,748,110,1208,1,78,748,1005,748,132,1208,1,87,748,1005,748,169,1208,1,82,748,1005,748,239,21102,1041,1,1,21101,0,73,0,1105,1,1421,21101,0,78,1,21101,1041,0,2,21102,1,88,0,1105,1,1301,21102,68,1,1,21102,1041,1,2,21102,1,103,0,1106,0,1301,1102,1,1,750,1106,0,298,21102,1,82,1,21102,1041,1,2,21101,125,0,0,1105,1,1301,1101,2,0,750,1106,0,298,21101,79,0,1,21101,0,1041,2,21102,1,147,0,1106,0,1301,21102,84,1,1,21101,1041,0,2,21102,1,162,0,1105,1,1301,1101,3,0,750,1105,1,298,21101,0,65,1,21101,0,1041,2,21102,1,184,0,1106,0,1301,21101,0,76,1,21101,0,1041,2,21101,199,0,0,1105,1,1301,21101,75,0,1,21102,1041,1,2,21102,1,214,0,1105,1,1301,21102,221,1,0,1106,0,1337,21101,10,0,1,21101,1041,0,2,21101,0,236,0,1105,1,1301,1106,0,553,21102,1,85,1,21102,1041,1,2,21101,254,0,0,1106,0,1301,21101,0,78,1,21102,1,1041,2,21102,269,1,0,1105,1,1301,21102,1,276,0,1106,0,1337,21102,1,10,1,21102,1041,1,2,21101,291,0,0,1106,0,1301,1101,0,1,755,1105,1,553,21101,0,32,1,21101,0,1041,2,21101,313,0,0,1106,0,1301,21102,1,320,0,1106,0,1337,21101,327,0,0,1105,1,1279,1201,1,0,749,21101,0,65,2,21102,1,73,3,21102,1,346,0,1106,0,1889,1206,1,367,1007,749,69,748,1005,748,360,1101,1,0,756,1001,749,-64,751,1106,0,406,1008,749,74,748,1006,748,381,1101,-1,0,751,1105,1,406,1008,749,84,748,1006,748,395,1101,0,-2,751,1106,0,406,21102,1,1100,1,21101,0,406,0,1106,0,1421,21101,0,32,1,21102,1100,1,2,21102,421,1,0,1106,0,1301,21101,428,0,0,1106,0,1337,21101,0,435,0,1105,1,1279,2102,1,1,749,1008,749,74,748,1006,748,453,1101,-1,0,752,1105,1,478,1008,749,84,748,1006,748,467,1101,0,-2,752,1105,1,478,21102,1,1168,1,21101,0,478,0,1105,1,1421,21102,485,1,0,1106,0,1337,21102,10,1,1,21101,1168,0,2,21102,500,1,0,1106,0,1301,1007,920,15,748,1005,748,518,21101,1209,0,1,21101,0,518,0,1106,0,1421,1002,920,3,529,1001,529,921,529,1001,750,0,0,1001,529,1,537,1002,751,1,0,1001,537,1,545,1001,752,0,0,1001,920,1,920,1106,0,13,1005,755,577,1006,756,570,21101,0,1100,1,21101,0,570,0,1106,0,1421,21101,0,987,1,1105,1,581,21101,0,1001,1,21102,588,1,0,1106,0,1378,1102,758,1,594,102,1,0,753,1006,753,654,21002,753,1,1,21101,0,610,0,1106,0,667,21101,0,0,1,21101,0,621,0,1105,1,1463,1205,1,647,21101,0,1015,1,21102,1,635,0,1106,0,1378,21102,1,1,1,21101,0,646,0,1106,0,1463,99,1001,594,1,594,1105,1,592,1006,755,664,1101,0,0,755,1105,1,647,4,754,99,109,2,1101,0,726,757,21201,-1,0,1,21101,0,9,2,21101,697,0,3,21102,1,692,0,1106,0,1913,109,-2,2106,0,0,109,2,1002,757,1,706,2101,0,-1,0,1001,757,1,757,109,-2,2105,1,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,255,63,159,191,95,127,223,0,46,68,200,234,187,123,126,182,53,62,125,236,61,103,204,168,235,114,77,108,214,42,140,102,245,170,172,70,166,136,107,106,188,115,50,163,78,124,205,139,203,162,190,110,86,183,184,98,39,157,35,99,228,231,254,54,59,158,49,215,238,154,100,109,242,247,199,248,113,58,143,101,181,229,87,142,120,252,202,175,216,198,220,111,218,243,241,56,92,250,76,237,141,213,38,57,167,189,178,197,177,152,222,69,51,85,251,212,233,55,230,94,219,201,84,171,239,93,232,179,137,71,122,249,47,246,196,185,207,173,156,217,119,79,174,169,153,206,121,60,244,43,138,118,117,186,227,221,34,226,253,116,155,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,20,73,110,112,117,116,32,105,110,115,116,114,117,99,116,105,111,110,115,58,10,13,10,87,97,108,107,105,110,103,46,46,46,10,10,13,10,82,117,110,110,105,110,103,46,46,46,10,10,25,10,68,105,100,110,39,116,32,109,97,107,101,32,105,116,32,97,99,114,111,115,115,58,10,10,58,73,110,118,97,108,105,100,32,111,112,101,114,97,116,105,111,110,59,32,101,120,112,101,99,116,101,100,32,115,111,109,101,116,104,105,110,103,32,108,105,107,101,32,65,78,68,44,32,79,82,44,32,111,114,32,78,79,84,67,73,110,118,97,108,105,100,32,102,105,114,115,116,32,97,114,103,117,109,101,110,116,59,32,101,120,112,101,99,116,101,100,32,115,111,109,101,116,104,105,110,103,32,108,105,107,101,32,65,44,32,66,44,32,67,44,32,68,44,32,74,44,32,111,114,32,84,40,73,110,118,97,108,105,100,32,115,101,99,111,110,100,32,97,114,103,117,109,101,110,116,59,32,101,120,112,101,99,116,101,100,32,74,32,111,114,32,84,52,79,117,116,32,111,102,32,109,101,109,111,114,121,59,32,97,116,32,109,111,115,116,32,49,53,32,105,110,115,116,114,117,99,116,105,111,110,115,32,99,97,110,32,98,101,32,115,116,111,114,101,100,0,109,1,1005,1262,1270,3,1262,20101,0,1262,0,109,-1,2105,1,0,109,1,21102,1288,1,0,1105,1,1263,21001,1262,0,0,1102,0,1,1262,109,-1,2105,1,0,109,5,21101,1310,0,0,1105,1,1279,21201,1,0,-2,22208,-2,-4,-1,1205,-1,1332,22101,0,-3,1,21102,1332,1,0,1105,1,1421,109,-5,2105,1,0,109,2,21102,1,1346,0,1106,0,1263,21208,1,32,-1,1205,-1,1363,21208,1,9,-1,1205,-1,1363,1105,1,1373,21102,1370,1,0,1105,1,1279,1105,1,1339,109,-2,2105,1,0,109,5,2102,1,-4,1386,20102,1,0,-2,22101,1,-4,-4,21101,0,0,-3,22208,-3,-2,-1,1205,-1,1416,2201,-4,-3,1408,4,0,21201,-3,1,-3,1106,0,1396,109,-5,2105,1,0,109,2,104,10,21202,-1,1,1,21102,1,1436,0,1106,0,1378,104,10,99,109,-2,2106,0,0,109,3,20002,594,753,-1,22202,-1,-2,-1,201,-1,754,754,109,-3,2105,1,0,109,10,21101,5,0,-5,21102,1,1,-4,21102,1,0,-3,1206,-9,1555,21102,3,1,-6,21101,0,5,-7,22208,-7,-5,-8,1206,-8,1507,22208,-6,-4,-8,1206,-8,1507,104,64,1105,1,1529,1205,-6,1527,1201,-7,716,1515,21002,0,-11,-8,21201,-8,46,-8,204,-8,1105,1,1529,104,46,21201,-7,1,-7,21207,-7,22,-8,1205,-8,1488,104,10,21201,-6,-1,-6,21207,-6,0,-8,1206,-8,1484,104,10,21207,-4,1,-8,1206,-8,1569,21102,1,0,-9,1105,1,1689,21208,-5,21,-8,1206,-8,1583,21101,1,0,-9,1105,1,1689,1201,-5,716,1589,20102,1,0,-2,21208,-4,1,-1,22202,-2,-1,-1,1205,-2,1613,21201,-5,0,1,21102,1613,1,0,1105,1,1444,1206,-1,1634,22102,1,-5,1,21101,0,1627,0,1106,0,1694,1206,1,1634,21102,2,1,-3,22107,1,-4,-8,22201,-1,-8,-8,1206,-8,1649,21201,-5,1,-5,1206,-3,1663,21201,-3,-1,-3,21201,-4,1,-4,1105,1,1667,21201,-4,-1,-4,21208,-4,0,-1,1201,-5,716,1676,22002,0,-1,-1,1206,-1,1686,21101,1,0,-4,1105,1,1477,109,-10,2106,0,0,109,11,21102,0,1,-6,21101,0,0,-8,21101,0,0,-7,20208,-6,920,-9,1205,-9,1880,21202,-6,3,-9,1201,-9,921,1725,20102,1,0,-5,1001,1725,1,1732,21002,0,1,-4,22102,1,-4,1,21102,1,1,2,21101,9,0,3,21101,0,1754,0,1105,1,1889,1206,1,1772,2201,-10,-4,1766,1001,1766,716,1766,21002,0,1,-3,1106,0,1790,21208,-4,-1,-9,1206,-9,1786,21202,-8,1,-3,1105,1,1790,22102,1,-7,-3,1001,1732,1,1796,20102,1,0,-2,21208,-2,-1,-9,1206,-9,1812,22102,1,-8,-1,1106,0,1816,22101,0,-7,-1,21208,-5,1,-9,1205,-9,1837,21208,-5,2,-9,1205,-9,1844,21208,-3,0,-1,1105,1,1855,22202,-3,-1,-1,1105,1,1855,22201,-3,-1,-1,22107,0,-1,-1,1105,1,1855,21208,-2,-1,-9,1206,-9,1869,22101,0,-1,-8,1106,0,1873,21201,-1,0,-7,21201,-6,1,-6,1105,1,1708,22101,0,-8,-10,109,-11,2105,1,0,109,7,22207,-6,-5,-3,22207,-4,-6,-2,22201,-3,-2,-1,21208,-1,0,-6,109,-7,2105,1,0,0,109,5,1201,-2,0,1912,21207,-4,0,-1,1206,-1,1930,21102,1,0,-4,21201,-4,0,1,22101,0,-3,2,21102,1,1,3,21101,1949,0,0,1105,1,1954,109,-5,2105,1,0,109,6,21207,-4,1,-1,1206,-1,1977,22207,-5,-3,-1,1206,-1,1977,21201,-5,0,-5,1105,1,2045,22101,0,-5,1,21201,-4,-1,2,21202,-3,2,3,21101,1996,0,0,1106,0,1954,22101,0,1,-5,21101,0,1,-2,22207,-5,-3,-1,1206,-1,2015,21102,0,1,-2,22202,-3,-2,-3,22107,0,-4,-1,1206,-1,2037,22101,0,-2,1,21102,2037,1,0,106,0,1912,21202,-3,-1,-3,22201,-5,-3,-5,109,-6,2105,1,0}

	// Part 1 with walking
	in, out := springDroidIOHandlers(false)
	runIntComp(springDroidProgram, in, out)

	// Part 2 with running
	in, out = springDroidIOHandlers(true)
	runIntComp(springDroidProgram, in, out)
}

func cutDeck(deck []int, cutNumber int) []int {
	if cutNumber > 0 {
		deck = append(deck[cutNumber:], deck[:cutNumber]...)
	} else {
		cutNumber = DeckSize + cutNumber
		deck = append(deck[cutNumber:], deck[:cutNumber]...)
	}
	return deck
}

func reverseDeck(deck []int) []int {
	for i, j := 0, len(deck)-1; i < j; i, j = i+1, j-1 {
		deck[i], deck[j] = deck[j], deck[i]
	}
	return deck
}

func dealDeckWithInterval(deck []int, interval int) []int {
	var tableSpace = make([]int, len(deck))
	for i, n := 0, 0; i < len(deck); i++ {
		tableSpace[n] = deck[i]
		n = (n + interval) % len(deck)
	}
	return tableSpace
}

func invBigInt(x , c *big.Int) *big.Int {
	bigInt := big.NewInt(0)
	retVal := bigInt.Exp(x, bigInt.Sub(c,  big.NewInt(2)), c)
	return retVal
}

const (
	DeckSize int = 10007
	BigDeckSize int = 119315717514047
)

func day22() {
	var spaceDeck = make([]int, DeckSize)
	var shuffles = []string{}
	file, err := os.Open("day22-input.txt")
	if err != nil {
		log.Fatal(err)
	}
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		shuffles = append(shuffles, scanner.Text())
	}

	defer file.Close()

	for i := 0; i < DeckSize; i++ {
		spaceDeck[i] = i
	}
	for i := 0; i < len(shuffles); i++ {
		line := shuffles[i]
		if strings.HasPrefix(line, "deal into") {
			spaceDeck = reverseDeck(spaceDeck)
		}
		if strings.HasPrefix(line, "cut ") {
			num, _ := strconv.ParseInt(strings.Split(line, " ")[1], 10, 64)
			spaceDeck = cutDeck(spaceDeck, int(num))
		}
		if strings.HasPrefix(line, "deal with") {
			num, _ := strconv.ParseInt(strings.Split(line, " ")[3], 10, 64)
			spaceDeck = dealDeckWithInterval(spaceDeck, int(num))
		}
	}

	for i, pos := 0, 0; pos == 0; i++ {
		if spaceDeck[i] == 2019 {
			pos = 1
			fmt.Println("Position of 2019:", i)
		}
	}

	// For part 2, we can't simulate the deck, so we'll have to keep track of operations instead
	// I've already pulled shuffles out into a set of strings for doing this often
	// Credit to the whole community with similar math for the pattern I'd never figure out

	var incrementRate = big.NewInt(1)
	var offset = big.NewInt(0)
	bigInt := big.NewInt(0)
	var bigIntDeckSize = big.NewInt(int64(BigDeckSize))
	shuffleTimes := big.NewInt(101741582076661)
	for lineNum := 0; lineNum < len(shuffles); lineNum++{
		line := shuffles[lineNum]
		if strings.HasPrefix(line, "cut ") {
			num, _ := strconv.ParseInt(strings.Split(line, " ")[1], 10, 64)
			offset.Add(offset, bigInt.Mul(incrementRate, big.NewInt(num)))
		}
		if strings.HasPrefix(line, "deal with") {
			num, _ := strconv.ParseInt(strings.Split(line, " ")[3], 10, 64)
			incrementRate.Mul(incrementRate, invBigInt(big.NewInt(num), bigIntDeckSize))
		}
		if strings.HasPrefix(line, "deal into") {
			offset.Sub(offset, incrementRate)
			incrementRate.Neg(incrementRate)
		}
	}

	// When I combine these into less lines, I break things a lot.  This is easier to follow as well.
	position := big.NewInt(2020)
	negIncrementRate := bigInt.Sub(big.NewInt(1), incrementRate)
	offset.Mul(offset, invBigInt(negIncrementRate, bigIntDeckSize))
	incrementRate.Exp(incrementRate, shuffleTimes, bigIntDeckSize)
	position.Mul(position, incrementRate)
	negIncrementRate = bigInt.Sub(big.NewInt(1), incrementRate)
	negIncrementRate.Mul(negIncrementRate, offset)
	added := bigInt.Add(position, negIncrementRate)
	position.Mod(added, bigIntDeckSize)

	fmt.Println("Card at 2020:", position)

	// Failed with 11071218642195
	// Failed with 115472293458660
	// Failed with 58767844608851
	// Failed with 115472293458736
	// Failed with 27707634465568
	// Failed with 61795058599718
	// Failed with 58484976126416
	// Failed with 82153917000203
	// Failed with 99293654523040
	// Answer is   70725194521472
}

type Int64Value struct {
	Value int64
}


// NewInt64Queue returns a new queue with the given initial size.
func NewInt64Queue(size int) *Int64Queue {
	return &Int64Queue{
		values: make([]*Int64Value, size),
		size:  size,
	}
}

// Queue is a basic FIFO queue based on a circular list that resizes as needed.
type Int64Queue struct {
	values []*Int64Value
	size  int
	head  int
	tail  int
	count int
}

// Push adds a node to the queue.
func (q *Int64Queue) Push(n *Int64Value) {
	if q.head == q.tail && q.count > 0 {
		nodes := make([]*Int64Value, len(q.values)+q.size)
		copy(nodes, q.values[q.head:])
		copy(nodes[len(q.values)-q.head:], q.values[:q.head])
		q.head = 0
		q.tail = len(q.values)
		q.values = nodes
	}
	q.values[q.tail] = n
	q.tail = (q.tail + 1) % len(q.values)
	q.count++
}

// Pop removes and returns a node from the queue in first to last order.
func (q *Int64Queue) Pop() *Int64Value {
	if q.count == 0 {
		return nil
	}
	node := q.values[q.head]
	q.head = (q.head + 1) % len(q.values)
	q.count--
	return node
}

func networkIOHandlers(address int64, queues []Int64Queue, first255 chan int64) (inputGatherer, outputHandler) {
	var addressGiven bool = false
	var phase int64
	var currentTo int64
	var first255Y bool = true
	var current255X int64
	var current255Y int64
	var lastY int64


	handle255 := func(value int64) {
		if first255Y {
			first255 <- value
			first255Y = false
		}
		var foundSending = false
		for i := 0; i < len(queues); i++ {
			if queues[i].count != 0 {
				fmt.Println("Comp receiving:", i)
				foundSending = true
			}
		}
		if !foundSending {
			fmt.Println("Found wanting")
			if current255Y == lastY {
				first255 <- current255Y
			}
			lastY = current255Y
			queues[0].Push(&Int64Value{current255X})
			queues[0].Push(&Int64Value{current255Y})
		}
	}

	in := func() int64 {
		if !addressGiven {
			addressGiven = true
			return address
		} else {
			nextVal := queues[address].Pop()
			if nextVal != nil {
				return nextVal.Value
			}
		}
		return -1
	}

	out := func(value int64) {
		switch phase {
		case 0:
			currentTo = value
		case 1:
			if currentTo != 255 {
				queues[currentTo].Push(&Int64Value{value})
			} else {
				current255X = value
			}
		case 2:
			if currentTo != 255 {
				queues[currentTo].Push(&Int64Value{value})
				fmt.Println("Sending packet to:", currentTo, "from:", address)
			} else {
				current255Y = value
				fmt.Println("255 from:", address)
				handle255(value)
			}
			phase = -1
		}
		phase++
	}

	return in, out
}

func day23() {
	var networkProgram = []int64{3,62,1001,62,11,10,109,2235,105,1,0,866,1686,1593,1717,633,767,1783,1150,1872,666,938,1418,1014,1119,2142,571,1841,1552,1653,1387,1981,1812,829,1748,1451,1909,2113,1282,1181,907,2014,602,977,1622,1317,2084,1940,1247,1515,1482,1216,2173,736,1045,2043,1082,703,798,1352,2204,0,0,0,0,0,0,0,0,0,0,0,0,3,64,1008,64,-1,62,1006,62,88,1006,61,170,1105,1,73,3,65,21001,64,0,1,20101,0,66,2,21102,1,105,0,1105,1,436,1201,1,-1,64,1007,64,0,62,1005,62,73,7,64,67,62,1006,62,73,1002,64,2,133,1,133,68,133,101,0,0,62,1001,133,1,140,8,0,65,63,2,63,62,62,1005,62,73,1002,64,2,161,1,161,68,161,1101,1,0,0,1001,161,1,169,1002,65,1,0,1102,1,1,61,1101,0,0,63,7,63,67,62,1006,62,203,1002,63,2,194,1,68,194,194,1006,0,73,1001,63,1,63,1106,0,178,21102,1,210,0,105,1,69,2102,1,1,70,1102,1,0,63,7,63,71,62,1006,62,250,1002,63,2,234,1,72,234,234,4,0,101,1,234,240,4,0,4,70,1001,63,1,63,1105,1,218,1106,0,73,109,4,21101,0,0,-3,21101,0,0,-2,20207,-2,67,-1,1206,-1,293,1202,-2,2,283,101,1,283,283,1,68,283,283,22001,0,-3,-3,21201,-2,1,-2,1106,0,263,21202,-3,1,-3,109,-4,2106,0,0,109,4,21101,1,0,-3,21102,0,1,-2,20207,-2,67,-1,1206,-1,342,1202,-2,2,332,101,1,332,332,1,68,332,332,22002,0,-3,-3,21201,-2,1,-2,1106,0,312,21201,-3,0,-3,109,-4,2105,1,0,109,1,101,1,68,359,20101,0,0,1,101,3,68,366,21002,0,1,2,21101,0,376,0,1105,1,436,21201,1,0,0,109,-1,2105,1,0,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262144,524288,1048576,2097152,4194304,8388608,16777216,33554432,67108864,134217728,268435456,536870912,1073741824,2147483648,4294967296,8589934592,17179869184,34359738368,68719476736,137438953472,274877906944,549755813888,1099511627776,2199023255552,4398046511104,8796093022208,17592186044416,35184372088832,70368744177664,140737488355328,281474976710656,562949953421312,1125899906842624,109,8,21202,-6,10,-5,22207,-7,-5,-5,1205,-5,521,21101,0,0,-4,21102,0,1,-3,21102,51,1,-2,21201,-2,-1,-2,1201,-2,385,470,21001,0,0,-1,21202,-3,2,-3,22207,-7,-1,-5,1205,-5,496,21201,-3,1,-3,22102,-1,-1,-5,22201,-7,-5,-7,22207,-3,-6,-5,1205,-5,515,22102,-1,-6,-5,22201,-3,-5,-3,22201,-1,-4,-4,1205,-2,461,1106,0,547,21102,1,-1,-4,21202,-6,-1,-6,21207,-7,0,-5,1205,-5,547,22201,-7,-6,-7,21201,-4,1,-4,1106,0,529,22101,0,-4,-7,109,-8,2105,1,0,109,1,101,1,68,564,20101,0,0,0,109,-1,2106,0,0,1102,43577,1,66,1101,1,0,67,1101,0,598,68,1101,0,556,69,1101,0,1,71,1101,600,0,72,1105,1,73,1,421,9,27718,1101,0,27697,66,1101,0,1,67,1101,629,0,68,1102,556,1,69,1102,1,1,71,1102,631,1,72,1105,1,73,1,-494360,10,30367,1101,92083,0,66,1102,1,2,67,1101,660,0,68,1101,351,0,69,1102,1,1,71,1101,664,0,72,1105,1,73,0,0,0,0,255,102059,1102,1,13859,66,1102,1,4,67,1102,1,693,68,1102,302,1,69,1101,1,0,71,1102,1,701,72,1105,1,73,0,0,0,0,0,0,0,0,46,11306,1102,5653,1,66,1102,2,1,67,1101,730,0,68,1101,302,0,69,1102,1,1,71,1102,1,734,72,1105,1,73,0,0,0,0,45,45789,1102,1,14753,66,1102,1,1,67,1101,0,763,68,1102,1,556,69,1101,0,1,71,1102,765,1,72,1105,1,73,1,11,32,178378,1101,0,57487,66,1102,1,1,67,1101,794,0,68,1102,556,1,69,1102,1,1,71,1102,1,796,72,1106,0,73,1,125,22,93871,1102,1,28279,66,1102,1,1,67,1102,1,825,68,1102,556,1,69,1101,1,0,71,1101,827,0,72,1106,0,73,1,-40,28,200366,1102,1,93871,66,1101,0,4,67,1102,1,856,68,1101,0,302,69,1101,1,0,71,1101,864,0,72,1105,1,73,0,0,0,0,0,0,0,0,36,197495,1101,0,102059,66,1101,0,1,67,1102,1,893,68,1101,0,556,69,1102,6,1,71,1101,0,895,72,1105,1,73,1,28727,46,5653,27,89599,27,268797,37,101963,37,203926,37,305889,1102,19069,1,66,1101,1,0,67,1102,1,934,68,1101,556,0,69,1102,1,1,71,1102,936,1,72,1105,1,73,1,160,36,236994,1101,30367,0,66,1101,0,5,67,1102,1,965,68,1102,1,253,69,1101,0,1,71,1102,975,1,72,1106,0,73,0,0,0,0,0,0,0,0,0,0,8,108753,1101,0,89189,66,1102,1,4,67,1102,1004,1,68,1102,302,1,69,1102,1,1,71,1102,1012,1,72,1106,0,73,0,0,0,0,0,0,0,0,45,15263,1101,0,19571,66,1102,1,1,67,1101,1041,0,68,1102,556,1,69,1101,1,0,71,1102,1043,1,72,1106,0,73,1,23593,23,57089,1101,0,76369,66,1101,0,4,67,1101,0,1072,68,1101,302,0,69,1101,1,0,71,1102,1080,1,72,1106,0,73,0,0,0,0,0,0,0,0,27,179198,1102,1,15263,66,1102,1,4,67,1102,1109,1,68,1101,0,253,69,1101,1,0,71,1102,1117,1,72,1105,1,73,0,0,0,0,0,0,0,0,4,92083,1102,102197,1,66,1102,1,1,67,1102,1146,1,68,1101,556,0,69,1101,1,0,71,1102,1,1148,72,1106,0,73,1,-17,23,171267,1102,26371,1,66,1102,1,1,67,1102,1,1177,68,1102,1,556,69,1102,1,1,71,1102,1179,1,72,1105,1,73,1,531210,10,151835,1102,100183,1,66,1102,3,1,67,1101,1208,0,68,1102,302,1,69,1101,1,0,71,1101,0,1214,72,1105,1,73,0,0,0,0,0,0,8,36251,1102,48799,1,66,1102,1,1,67,1101,1243,0,68,1101,556,0,69,1101,1,0,71,1102,1245,1,72,1106,0,73,1,31,38,364396,1101,0,101963,66,1102,3,1,67,1101,1274,0,68,1102,1,302,69,1101,0,1,71,1102,1,1280,72,1106,0,73,0,0,0,0,0,0,45,30526,1102,89599,1,66,1101,0,3,67,1101,1309,0,68,1102,1,302,69,1102,1,1,71,1102,1,1315,72,1106,0,73,0,0,0,0,0,0,45,61052,1102,1,40867,66,1102,1,3,67,1102,1344,1,68,1101,0,302,69,1101,0,1,71,1102,1,1350,72,1105,1,73,0,0,0,0,0,0,9,55436,1102,571,1,66,1101,1,0,67,1101,1379,0,68,1102,1,556,69,1101,3,0,71,1101,0,1381,72,1105,1,73,1,5,22,281613,22,375484,36,118497,1101,27073,0,66,1102,1,1,67,1101,0,1414,68,1101,556,0,69,1101,1,0,71,1102,1416,1,72,1106,0,73,1,3,43,305476,1101,0,61967,66,1101,2,0,67,1101,1445,0,68,1101,0,302,69,1101,1,0,71,1101,1449,0,72,1106,0,73,0,0,0,0,18,95261,1102,1,74287,66,1102,1,1,67,1101,1478,0,68,1101,0,556,69,1101,1,0,71,1101,1480,0,72,1106,0,73,1,25,38,273297,1102,69761,1,66,1102,1,1,67,1101,0,1509,68,1102,1,556,69,1101,2,0,71,1101,0,1511,72,1106,0,73,1,10,22,187742,36,78998,1101,91099,0,66,1102,4,1,67,1101,1542,0,68,1102,302,1,69,1102,1,1,71,1102,1550,1,72,1105,1,73,0,0,0,0,0,0,0,0,8,145004,1102,1,20959,66,1101,1,0,67,1102,1,1579,68,1101,0,556,69,1102,6,1,71,1101,0,1581,72,1106,0,73,1,2,11,123934,18,190522,32,356756,43,152738,36,39499,36,157996,1101,0,41051,66,1102,1,1,67,1101,1620,0,68,1102,1,556,69,1102,1,0,71,1102,1622,1,72,1106,0,73,1,1124,1101,0,64667,66,1101,0,1,67,1101,1649,0,68,1101,0,556,69,1102,1,1,71,1101,1651,0,72,1106,0,73,1,14419,28,100183,1101,95261,0,66,1102,1,2,67,1101,1680,0,68,1102,302,1,69,1101,0,1,71,1101,1684,0,72,1106,0,73,0,0,0,0,32,89189,1102,1499,1,66,1101,0,1,67,1101,0,1713,68,1102,1,556,69,1101,1,0,71,1101,0,1715,72,1105,1,73,1,584586,10,121468,1101,0,51071,66,1101,1,0,67,1101,1744,0,68,1102,1,556,69,1102,1,1,71,1101,0,1746,72,1106,0,73,1,747,38,91099,1101,0,57089,66,1101,3,0,67,1102,1,1775,68,1101,0,302,69,1101,0,1,71,1101,0,1781,72,1106,0,73,0,0,0,0,0,0,8,72502,1101,0,53693,66,1101,1,0,67,1101,1810,0,68,1102,556,1,69,1102,1,0,71,1102,1812,1,72,1105,1,73,1,1468,1102,78787,1,66,1101,0,1,67,1102,1,1839,68,1102,556,1,69,1101,0,0,71,1101,0,1841,72,1106,0,73,1,1513,1102,64187,1,66,1101,0,1,67,1101,0,1868,68,1102,556,1,69,1101,0,1,71,1101,1870,0,72,1105,1,73,1,109,9,41577,1101,36251,0,66,1101,4,0,67,1101,1899,0,68,1102,1,253,69,1101,0,1,71,1102,1,1907,72,1105,1,73,0,0,0,0,0,0,0,0,11,61967,1101,48871,0,66,1101,1,0,67,1102,1936,1,68,1101,0,556,69,1101,1,0,71,1102,1,1938,72,1106,0,73,1,1033006,10,91101,1102,1,39499,66,1101,0,6,67,1101,1967,0,68,1102,302,1,69,1101,1,0,71,1101,1979,0,72,1106,0,73,0,0,0,0,0,0,0,0,0,0,0,0,4,184166,1101,6359,0,66,1101,1,0,67,1102,2008,1,68,1102,1,556,69,1102,1,2,71,1101,0,2010,72,1105,1,73,1,-9749,32,267567,43,229107,1101,0,37663,66,1101,0,1,67,1101,2041,0,68,1101,0,556,69,1101,0,0,71,1102,1,2043,72,1105,1,73,1,1920,1101,0,80953,66,1102,1,1,67,1101,0,2070,68,1102,1,556,69,1101,0,6,71,1102,2072,1,72,1105,1,73,1,1,38,182198,23,114178,28,300549,34,40867,9,13859,43,76369,1101,44179,0,66,1102,1,1,67,1101,0,2111,68,1102,556,1,69,1101,0,0,71,1101,2113,0,72,1106,0,73,1,1102,1101,0,24977,66,1101,0,1,67,1102,2140,1,68,1101,0,556,69,1101,0,0,71,1102,1,2142,72,1105,1,73,1,1031,1101,0,15289,66,1101,0,1,67,1101,2169,0,68,1102,1,556,69,1102,1,1,71,1101,0,2171,72,1106,0,73,1,271,34,81734,1102,68597,1,66,1101,0,1,67,1102,2200,1,68,1102,556,1,69,1102,1,1,71,1101,2202,0,72,1105,1,73,1,566565,10,60734,1101,0,5683,66,1102,1,1,67,1101,0,2231,68,1101,556,0,69,1101,0,1,71,1101,0,2233,72,1105,1,73,1,148,34,122601}

	var queues = []Int64Queue{}
	var first255 chan int64 = make(chan int64, 51)

	// Yes, I am aware this is vulnerable to race conditions.  Sorry my puzzle isn't production ready.
	for i := int64(0); i < 51; i++ {
		queues = append(queues, *NewInt64Queue(50))
	}
	for i := int64(0); i < 50; i++ {
		in, out := networkIOHandlers(i, queues, first255)
		go runIntComp(networkProgram, in, out)
	}
	value := <- first255

	fmt.Println("First 255 Y:", value)

	value = <- first255

	fmt.Println("First Y twice:", value)
}

func reconcileBugs(initial []string) string {
	var width = len(initial[0])
	var height = len(initial)
	var next = []string{}

	for y := 0; y < height; y++ {
		nextRow := []string{}
		for x := 0; x < width; x++ {
			current := string(initial[y][x])
			adjacent := 0
			if x < width - 1 && initial[y][x+1] == '#' { adjacent++ }
			if x > 0 && initial[y][x-1] == '#' { adjacent++ }
			if y < height - 1 && initial[y+1][x] == '#' { adjacent++ }
			if y > 0 && initial[y-1][x] == '#' { adjacent++ }

			if current == "#" && adjacent != 1 {
				nextRow = append(nextRow, ".")
			} else if current == "." && (adjacent == 1 || adjacent == 2) {
				nextRow = append(nextRow, "#")
			} else {
				nextRow = append(nextRow, current)
			}
		}
		next = append(next, strings.Join(nextRow, ""))
	}
	return strings.Join(next,",")
}

func calculateBiodiversityRating(field []string) int {
	setup := strings.Join(field, "")

	var total int
	for i := 0; i < len(setup); i++ {
		if setup[i] == '#' {
			value := 1 << i
			total += value
		}
	}
	return total
}

type BugTile struct {
	biodiversityRating int64
	adjacentBugCount   int64
	tile               string
	hasBug             bool
}

func day24() {
	var input = []string{
		"####.",
		".###.",
		".#..#",
		"##.##",
		"###..",
	}

	var seen = map[string]int{}
	var order = []string{}

	flattened := strings.Join(input,",")
	seen[flattened] = 1
	order = append(order, flattened)
	var seenTwice []string
	for i := 0; ; i++ {
		var next = reconcileBugs(strings.Split(order[i], ","))
		seen[next] += 1
		order = append(order, next)
		if seen[next] == 2 {
			fmt.Println("Found at minute: ", i)
			seenTwice = strings.Split(next, ",")
			break
		}
	}

	var rating = calculateBiodiversityRating(seenTwice)

	fmt.Println("Tile first seen twice:")
	fmt.Println(strings.Join(seenTwice, "\n"))
	fmt.Println("Biodiversity rating:", rating)

	// Failed with 8243663
	// Answer is 32511025

	// Part 2 stuff adapted from JacobPuff's version
	// I make these maps so that I can get the adjacent bugs for them,
	// and the other levels should be handled from there
	var availableDirs = []int64{NORTH, SOUTH, WEST, EAST}
	var bugMap = make(map[gridPoint]BugTile)
	var levelMap = make(map[int64]map[gridPoint]BugTile)
	levelMap[0] = make(map[gridPoint]BugTile)
	levelMap[-1] = make(map[gridPoint]BugTile)
	levelMap[1] = make(map[gridPoint]BugTile)
	var x, y, width, height, bugsPressentAfter200Minutes  int64

	noCommaFlattened := strings.Join(input,"")
	for i := int64(0); i < int64(len(noCommaFlattened)); i++ {
		x = i % 5
		y = i / 5
		char := noCommaFlattened[i]
		var newBugTile BugTile
		newBugTile.biodiversityRating = 1 << i
		newBugTile.tile = string(char)
		if char == '#' {
			newBugTile.hasBug = true
		}
		bugMap[gridPoint{x, y}] = newBugTile
		levelMap[0][gridPoint{x, y}] = newBugTile
	}
	fmt.Println(levelMap[0])

	// Width and height are the edges, not a count of the items on each axis,
	// and the grid starts at 0, so I dont need to subtract 1 for an offset.
	width = 4
	height = 4
	hole := gridPoint{width / 2, height / 2}
	var minutesPassed = 0
	for minutesPassed <= 200 {
		for level, levelBugMap := range levelMap {
			if levelMap[level-1] == nil {
				levelMap[level-1] = make(map[gridPoint]BugTile)
			}
			if levelMap[level+1] == nil {
				levelMap[level+1] = make(map[gridPoint]BugTile)
			}
			for y = 0; y <= height; y++ {
				for x = 0; x <= width; x++ {
					bugTile := levelBugMap[gridPoint{x, y}]
					bugPoint := gridPoint{x, y}
					bugTile.adjacentBugCount = 0

					if bugPoint != hole {
						for _, dir := range availableDirs {
							checkBugPoint := getPointForDirection(dir, bugPoint)
							// Handle outside edges
							if checkBugPoint.x == -1 {
								if levelMap[level-1][gridPoint{hole.x - 1, hole.y}].hasBug {
									bugTile.adjacentBugCount++
								}
							} else if checkBugPoint.y == -1 {
								if levelMap[level-1][gridPoint{hole.x, hole.y - 1}].hasBug {
									bugTile.adjacentBugCount++
								}

							} else if checkBugPoint.x == width+1 {
								if levelMap[level-1][gridPoint{hole.x + 1, hole.y}].hasBug {
									bugTile.adjacentBugCount++
								}
							} else if checkBugPoint.y == width+1 {
								if levelMap[level-1][gridPoint{hole.x, hole.y + 1}].hasBug {
									bugTile.adjacentBugCount++
								}
							}

							// Handle inside edges.
							var checkX, checkY int64
							if bugPoint == (gridPoint{hole.x - 1, hole.y}) && checkBugPoint == hole {
								for checkY = 0; checkY <= height; checkY++ {
									if levelMap[level+1][gridPoint{0, checkY}].hasBug {
										bugTile.adjacentBugCount++
									}
								}
							} else if bugPoint == (gridPoint{hole.x, hole.y - 1}) && checkBugPoint == hole {
								for checkX = 0; checkX <= width; checkX++ {
									if levelMap[level+1][gridPoint{checkX, 0}].hasBug {
										bugTile.adjacentBugCount++
									}
								}
							} else if bugPoint == (gridPoint{hole.x + 1, hole.y}) && checkBugPoint == hole {
								for checkY = 0; checkY <= height; checkY++ {
									if levelMap[level+1][gridPoint{width, checkY}].hasBug {
										bugTile.adjacentBugCount++
									}
								}
							} else if bugPoint == (gridPoint{hole.x, hole.y + 1}) && checkBugPoint == hole {
								for checkX = 0; checkX <= width; checkX++ {
									if levelMap[level+1][gridPoint{checkX, height}].hasBug {
										bugTile.adjacentBugCount++
									}
								}
							}

							// Handle everything else
							if levelBugMap[checkBugPoint].hasBug {
								bugTile.adjacentBugCount++
							}
						}
					}
					levelBugMap[gridPoint{x, y}] = bugTile
				}
			}
		}

		if minutesPassed == 200 {
			for _, levelBugMap := range levelMap {
				for y = 0; y <= height; y++ {
					for x = 0; x <= width; x++ {
						bugTile := levelBugMap[gridPoint{x, y}]
						if bugTile.hasBug {
							bugsPressentAfter200Minutes++
						}
					}
				}
			}
		} else {
			for _, levelBugMap := range levelMap {
				for y = 0; y <= height; y++ {
					for x = 0; x <= width; x++ {
						bugTile := levelBugMap[gridPoint{x, y}]
						if bugTile.hasBug {
							if bugTile.adjacentBugCount != 1 {
								bugTile.tile = "."
								bugTile.hasBug = false
							}
						} else {
							if bugTile.adjacentBugCount == 1 || bugTile.adjacentBugCount == 2 {
								bugTile.tile = "#"
								bugTile.hasBug = true
							}
						}
						levelBugMap[gridPoint{x, y}] = bugTile
					}
				}
			}
		}
		minutesPassed++
	}

	// Failed with 1939 (too high)
	// Answer is 1932

	fmt.Println("Biodiversity rating of first layout that appears twice:", rating)
	fmt.Println("Bugs present after 200 minutes:", bugsPressentAfter200Minutes)

}